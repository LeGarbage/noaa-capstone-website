export default reader;
export type eatable = "char" | "line" | "whitespaces" | "newline" | RegExp | number;
/**
 * @param {CoreAPI} _core
 * @param {Partial<Range>} [range={}]
 */
declare function reader(_core: CoreAPI, range?: Partial<Range>): {
    getChar: (offset?: number) => string | undefined;
    getLine: () => string | null;
    eat: (param?: eatable) => {
        position: Position;
        value: string;
    } | undefined;
    jump: (point: Point | number) => void;
    match: (pattern: RegExp, range?: Partial<Position>) => {
        result: RegExpExecArray;
        position: {
            start: Point;
            end: Point;
        };
    } | undefined;
    indexOf: (str: string, range?: Partial<Position>) => Point | null;
    findClosing: (index?: Point | number) => Point | undefined;
    isStartOfLine: () => boolean;
    now: () => Point;
    beginOfLine: () => Point | undefined;
    endOfLine: () => Point | undefined;
    /**
     * Read a range of text
     * @param {Partial<Range>} [range={}]
     */
    read: (range?: Partial<Range>) => {
        getChar: (offset?: number) => string | undefined;
        getLine: () => string | null;
        eat: (param?: eatable) => {
            position: Position;
            value: string;
        } | undefined;
        jump: (point: Point | number) => void;
        match: (pattern: RegExp, range?: Partial<Position>) => {
            result: RegExpExecArray;
            position: {
                start: Point;
                end: Point;
            };
        } | undefined;
        indexOf: (str: string, range?: Partial<Position>) => Point | null;
        findClosing: (index?: Point | number) => Point | undefined;
        isStartOfLine: () => boolean;
        now: () => Point;
        beginOfLine: () => Point | undefined;
        endOfLine: () => Point | undefined;
        read: /*elided*/ any;
        text: string;
        numberOfLines: number;
        toPoint: (index: number) => Point;
        toIndex: (point: Point | number) => number;
        bol: (ln: number) => Point | null;
        eol: (ln: number) => Point | null;
        shift: (point: Point, offset: number) => Point;
        linePosition: import("./utils/lines.js").linePosition;
        substring: import("./utils/substring.js").substring;
    };
    text: string;
    numberOfLines: number;
    toPoint: (index: number) => Point;
    toIndex: (point: Point | number) => number;
    bol: (ln: number) => Point | null;
    eol: (ln: number) => Point | null;
    shift: (point: Point, offset: number) => Point;
    linePosition: import("./utils/lines.js").linePosition;
    substring: import("./utils/substring.js").substring;
};
import type { CoreAPI } from './core.js';
import type { Range } from '../index.js';
import type { Position } from 'unist';
import type { Point } from 'unist';
//# sourceMappingURL=reader.d.ts.map