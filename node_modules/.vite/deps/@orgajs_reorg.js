import {
  VFile,
  ok
} from "./chunk-QQSUQN2C.js";
import {
  __commonJS,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/extend/index.js
var require_extend = __commonJS({
  "node_modules/extend/index.js"(exports, module) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray = function isArray2(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject2 = function isPlainObject3(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    module.exports = function extend2() {
      var options, name, src, copy, copyIsArray, clone2;
      var target = arguments[0];
      var i = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i < length; ++i) {
        options = arguments[i];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy = getProperty(options, name);
            if (target !== copy) {
              if (deep && copy && (isPlainObject2(copy) || (copyIsArray = isArray(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone2 = src && isArray(src) ? src : [];
                } else {
                  clone2 = src && isPlainObject2(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend2(deep, clone2, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// node_modules/@babel/runtime/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS({
  "node_modules/@babel/runtime/helpers/interopRequireDefault.js"(exports, module) {
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : {
        "default": e
      };
    }
    module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    function _typeof(o) {
      "@babel/helpers - typeof";
      return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
    }
    module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/date-fns/_lib/requiredArgs/index.js
var require_requiredArgs = __commonJS({
  "node_modules/date-fns/_lib/requiredArgs/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = requiredArgs;
    function requiredArgs(required, args) {
      if (args.length < required) {
        throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
      }
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/isDate/index.js
var require_isDate = __commonJS({
  "node_modules/date-fns/isDate/index.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isDate;
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _index = _interopRequireDefault(require_requiredArgs());
    function isDate(value) {
      (0, _index.default)(1, arguments);
      return value instanceof Date || (0, _typeof2.default)(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/toDate/index.js
var require_toDate = __commonJS({
  "node_modules/date-fns/toDate/index.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toDate2;
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _index = _interopRequireDefault(require_requiredArgs());
    function toDate2(argument) {
      (0, _index.default)(1, arguments);
      var argStr = Object.prototype.toString.call(argument);
      if (argument instanceof Date || (0, _typeof2.default)(argument) === "object" && argStr === "[object Date]") {
        return new Date(argument.getTime());
      } else if (typeof argument === "number" || argStr === "[object Number]") {
        return new Date(argument);
      } else {
        if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
          console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
          console.warn(new Error().stack);
        }
        return /* @__PURE__ */ new Date(NaN);
      }
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/isValid/index.js
var require_isValid = __commonJS({
  "node_modules/date-fns/isValid/index.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isValid;
    var _index = _interopRequireDefault(require_isDate());
    var _index2 = _interopRequireDefault(require_toDate());
    var _index3 = _interopRequireDefault(require_requiredArgs());
    function isValid(dirtyDate) {
      (0, _index3.default)(1, arguments);
      if (!(0, _index.default)(dirtyDate) && typeof dirtyDate !== "number") {
        return false;
      }
      var date = (0, _index2.default)(dirtyDate);
      return !isNaN(Number(date));
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/toInteger/index.js
var require_toInteger = __commonJS({
  "node_modules/date-fns/_lib/toInteger/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toInteger2;
    function toInteger2(dirtyNumber) {
      if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
        return NaN;
      }
      var number = Number(dirtyNumber);
      if (isNaN(number)) {
        return number;
      }
      return number < 0 ? Math.ceil(number) : Math.floor(number);
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/addMilliseconds/index.js
var require_addMilliseconds = __commonJS({
  "node_modules/date-fns/addMilliseconds/index.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = addMilliseconds;
    var _index = _interopRequireDefault(require_toInteger());
    var _index2 = _interopRequireDefault(require_toDate());
    var _index3 = _interopRequireDefault(require_requiredArgs());
    function addMilliseconds(dirtyDate, dirtyAmount) {
      (0, _index3.default)(2, arguments);
      var timestamp = (0, _index2.default)(dirtyDate).getTime();
      var amount = (0, _index.default)(dirtyAmount);
      return new Date(timestamp + amount);
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/subMilliseconds/index.js
var require_subMilliseconds = __commonJS({
  "node_modules/date-fns/subMilliseconds/index.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = subMilliseconds;
    var _index = _interopRequireDefault(require_addMilliseconds());
    var _index2 = _interopRequireDefault(require_requiredArgs());
    var _index3 = _interopRequireDefault(require_toInteger());
    function subMilliseconds(dirtyDate, dirtyAmount) {
      (0, _index2.default)(2, arguments);
      var amount = (0, _index3.default)(dirtyAmount);
      return (0, _index.default)(dirtyDate, -amount);
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/getUTCDayOfYear/index.js
var require_getUTCDayOfYear = __commonJS({
  "node_modules/date-fns/_lib/getUTCDayOfYear/index.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getUTCDayOfYear;
    var _index = _interopRequireDefault(require_toDate());
    var _index2 = _interopRequireDefault(require_requiredArgs());
    var MILLISECONDS_IN_DAY = 864e5;
    function getUTCDayOfYear(dirtyDate) {
      (0, _index2.default)(1, arguments);
      var date = (0, _index.default)(dirtyDate);
      var timestamp = date.getTime();
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
      var startOfYearTimestamp = date.getTime();
      var difference = timestamp - startOfYearTimestamp;
      return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/startOfUTCISOWeek/index.js
var require_startOfUTCISOWeek = __commonJS({
  "node_modules/date-fns/_lib/startOfUTCISOWeek/index.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = startOfUTCISOWeek;
    var _index = _interopRequireDefault(require_toDate());
    var _index2 = _interopRequireDefault(require_requiredArgs());
    function startOfUTCISOWeek(dirtyDate) {
      (0, _index2.default)(1, arguments);
      var weekStartsOn = 1;
      var date = (0, _index.default)(dirtyDate);
      var day = date.getUTCDay();
      var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      date.setUTCDate(date.getUTCDate() - diff);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/getUTCISOWeekYear/index.js
var require_getUTCISOWeekYear = __commonJS({
  "node_modules/date-fns/_lib/getUTCISOWeekYear/index.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getUTCISOWeekYear;
    var _index = _interopRequireDefault(require_toDate());
    var _index2 = _interopRequireDefault(require_requiredArgs());
    var _index3 = _interopRequireDefault(require_startOfUTCISOWeek());
    function getUTCISOWeekYear(dirtyDate) {
      (0, _index2.default)(1, arguments);
      var date = (0, _index.default)(dirtyDate);
      var year = date.getUTCFullYear();
      var fourthOfJanuaryOfNextYear = /* @__PURE__ */ new Date(0);
      fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
      fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
      var startOfNextYear = (0, _index3.default)(fourthOfJanuaryOfNextYear);
      var fourthOfJanuaryOfThisYear = /* @__PURE__ */ new Date(0);
      fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
      fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
      var startOfThisYear = (0, _index3.default)(fourthOfJanuaryOfThisYear);
      if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/startOfUTCISOWeekYear/index.js
var require_startOfUTCISOWeekYear = __commonJS({
  "node_modules/date-fns/_lib/startOfUTCISOWeekYear/index.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = startOfUTCISOWeekYear;
    var _index = _interopRequireDefault(require_getUTCISOWeekYear());
    var _index2 = _interopRequireDefault(require_startOfUTCISOWeek());
    var _index3 = _interopRequireDefault(require_requiredArgs());
    function startOfUTCISOWeekYear(dirtyDate) {
      (0, _index3.default)(1, arguments);
      var year = (0, _index.default)(dirtyDate);
      var fourthOfJanuary = /* @__PURE__ */ new Date(0);
      fourthOfJanuary.setUTCFullYear(year, 0, 4);
      fourthOfJanuary.setUTCHours(0, 0, 0, 0);
      var date = (0, _index2.default)(fourthOfJanuary);
      return date;
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/getUTCISOWeek/index.js
var require_getUTCISOWeek = __commonJS({
  "node_modules/date-fns/_lib/getUTCISOWeek/index.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getUTCISOWeek;
    var _index = _interopRequireDefault(require_toDate());
    var _index2 = _interopRequireDefault(require_startOfUTCISOWeek());
    var _index3 = _interopRequireDefault(require_startOfUTCISOWeekYear());
    var _index4 = _interopRequireDefault(require_requiredArgs());
    var MILLISECONDS_IN_WEEK = 6048e5;
    function getUTCISOWeek(dirtyDate) {
      (0, _index4.default)(1, arguments);
      var date = (0, _index.default)(dirtyDate);
      var diff = (0, _index2.default)(date).getTime() - (0, _index3.default)(date).getTime();
      return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/defaultOptions/index.js
var require_defaultOptions = __commonJS({
  "node_modules/date-fns/_lib/defaultOptions/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getDefaultOptions = getDefaultOptions;
    exports.setDefaultOptions = setDefaultOptions;
    var defaultOptions2 = {};
    function getDefaultOptions() {
      return defaultOptions2;
    }
    function setDefaultOptions(newOptions) {
      defaultOptions2 = newOptions;
    }
  }
});

// node_modules/date-fns/_lib/startOfUTCWeek/index.js
var require_startOfUTCWeek = __commonJS({
  "node_modules/date-fns/_lib/startOfUTCWeek/index.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = startOfUTCWeek;
    var _index = _interopRequireDefault(require_toDate());
    var _index2 = _interopRequireDefault(require_requiredArgs());
    var _index3 = _interopRequireDefault(require_toInteger());
    var _index4 = require_defaultOptions();
    function startOfUTCWeek(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
      (0, _index2.default)(1, arguments);
      var defaultOptions2 = (0, _index4.getDefaultOptions)();
      var weekStartsOn = (0, _index3.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
      }
      var date = (0, _index.default)(dirtyDate);
      var day = date.getUTCDay();
      var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      date.setUTCDate(date.getUTCDate() - diff);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/getUTCWeekYear/index.js
var require_getUTCWeekYear = __commonJS({
  "node_modules/date-fns/_lib/getUTCWeekYear/index.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getUTCWeekYear;
    var _index = _interopRequireDefault(require_toDate());
    var _index2 = _interopRequireDefault(require_requiredArgs());
    var _index3 = _interopRequireDefault(require_startOfUTCWeek());
    var _index4 = _interopRequireDefault(require_toInteger());
    var _index5 = require_defaultOptions();
    function getUTCWeekYear(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
      (0, _index2.default)(1, arguments);
      var date = (0, _index.default)(dirtyDate);
      var year = date.getUTCFullYear();
      var defaultOptions2 = (0, _index5.getDefaultOptions)();
      var firstWeekContainsDate = (0, _index4.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
      }
      var firstWeekOfNextYear = /* @__PURE__ */ new Date(0);
      firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
      firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
      var startOfNextYear = (0, _index3.default)(firstWeekOfNextYear, options);
      var firstWeekOfThisYear = /* @__PURE__ */ new Date(0);
      firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
      firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
      var startOfThisYear = (0, _index3.default)(firstWeekOfThisYear, options);
      if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/startOfUTCWeekYear/index.js
var require_startOfUTCWeekYear = __commonJS({
  "node_modules/date-fns/_lib/startOfUTCWeekYear/index.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = startOfUTCWeekYear;
    var _index = _interopRequireDefault(require_getUTCWeekYear());
    var _index2 = _interopRequireDefault(require_requiredArgs());
    var _index3 = _interopRequireDefault(require_startOfUTCWeek());
    var _index4 = _interopRequireDefault(require_toInteger());
    var _index5 = require_defaultOptions();
    function startOfUTCWeekYear(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
      (0, _index2.default)(1, arguments);
      var defaultOptions2 = (0, _index5.getDefaultOptions)();
      var firstWeekContainsDate = (0, _index4.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
      var year = (0, _index.default)(dirtyDate, options);
      var firstWeek = /* @__PURE__ */ new Date(0);
      firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
      firstWeek.setUTCHours(0, 0, 0, 0);
      var date = (0, _index3.default)(firstWeek, options);
      return date;
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/getUTCWeek/index.js
var require_getUTCWeek = __commonJS({
  "node_modules/date-fns/_lib/getUTCWeek/index.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getUTCWeek;
    var _index = _interopRequireDefault(require_toDate());
    var _index2 = _interopRequireDefault(require_startOfUTCWeek());
    var _index3 = _interopRequireDefault(require_startOfUTCWeekYear());
    var _index4 = _interopRequireDefault(require_requiredArgs());
    var MILLISECONDS_IN_WEEK = 6048e5;
    function getUTCWeek(dirtyDate, options) {
      (0, _index4.default)(1, arguments);
      var date = (0, _index.default)(dirtyDate);
      var diff = (0, _index2.default)(date, options).getTime() - (0, _index3.default)(date, options).getTime();
      return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/addLeadingZeros/index.js
var require_addLeadingZeros = __commonJS({
  "node_modules/date-fns/_lib/addLeadingZeros/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = addLeadingZeros;
    function addLeadingZeros(number, targetLength) {
      var sign = number < 0 ? "-" : "";
      var output = Math.abs(number).toString();
      while (output.length < targetLength) {
        output = "0" + output;
      }
      return sign + output;
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/format/lightFormatters/index.js
var require_lightFormatters = __commonJS({
  "node_modules/date-fns/_lib/format/lightFormatters/index.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = _interopRequireDefault(require_addLeadingZeros());
    var formatters = {
      // Year
      y: function y(date, token) {
        var signedYear = date.getUTCFullYear();
        var year = signedYear > 0 ? signedYear : 1 - signedYear;
        return (0, _index.default)(token === "yy" ? year % 100 : year, token.length);
      },
      // Month
      M: function M(date, token) {
        var month = date.getUTCMonth();
        return token === "M" ? String(month + 1) : (0, _index.default)(month + 1, 2);
      },
      // Day of the month
      d: function d(date, token) {
        return (0, _index.default)(date.getUTCDate(), token.length);
      },
      // AM or PM
      a: function a(date, token) {
        var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
        switch (token) {
          case "a":
          case "aa":
            return dayPeriodEnumValue.toUpperCase();
          case "aaa":
            return dayPeriodEnumValue;
          case "aaaaa":
            return dayPeriodEnumValue[0];
          case "aaaa":
          default:
            return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
        }
      },
      // Hour [1-12]
      h: function h(date, token) {
        return (0, _index.default)(date.getUTCHours() % 12 || 12, token.length);
      },
      // Hour [0-23]
      H: function H(date, token) {
        return (0, _index.default)(date.getUTCHours(), token.length);
      },
      // Minute
      m: function m(date, token) {
        return (0, _index.default)(date.getUTCMinutes(), token.length);
      },
      // Second
      s: function s(date, token) {
        return (0, _index.default)(date.getUTCSeconds(), token.length);
      },
      // Fraction of second
      S: function S(date, token) {
        var numberOfDigits = token.length;
        var milliseconds = date.getUTCMilliseconds();
        var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
        return (0, _index.default)(fractionalSeconds, token.length);
      }
    };
    var _default = formatters;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/format/formatters/index.js
var require_formatters = __commonJS({
  "node_modules/date-fns/_lib/format/formatters/index.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = _interopRequireDefault(require_getUTCDayOfYear());
    var _index2 = _interopRequireDefault(require_getUTCISOWeek());
    var _index3 = _interopRequireDefault(require_getUTCISOWeekYear());
    var _index4 = _interopRequireDefault(require_getUTCWeek());
    var _index5 = _interopRequireDefault(require_getUTCWeekYear());
    var _index6 = _interopRequireDefault(require_addLeadingZeros());
    var _index7 = _interopRequireDefault(require_lightFormatters());
    var dayPeriodEnum = {
      am: "am",
      pm: "pm",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    };
    var formatters = {
      // Era
      G: function G(date, token, localize) {
        var era = date.getUTCFullYear() > 0 ? 1 : 0;
        switch (token) {
          // AD, BC
          case "G":
          case "GG":
          case "GGG":
            return localize.era(era, {
              width: "abbreviated"
            });
          // A, B
          case "GGGGG":
            return localize.era(era, {
              width: "narrow"
            });
          // Anno Domini, Before Christ
          case "GGGG":
          default:
            return localize.era(era, {
              width: "wide"
            });
        }
      },
      // Year
      y: function y(date, token, localize) {
        if (token === "yo") {
          var signedYear = date.getUTCFullYear();
          var year = signedYear > 0 ? signedYear : 1 - signedYear;
          return localize.ordinalNumber(year, {
            unit: "year"
          });
        }
        return _index7.default.y(date, token);
      },
      // Local week-numbering year
      Y: function Y(date, token, localize, options) {
        var signedWeekYear = (0, _index5.default)(date, options);
        var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
        if (token === "YY") {
          var twoDigitYear = weekYear % 100;
          return (0, _index6.default)(twoDigitYear, 2);
        }
        if (token === "Yo") {
          return localize.ordinalNumber(weekYear, {
            unit: "year"
          });
        }
        return (0, _index6.default)(weekYear, token.length);
      },
      // ISO week-numbering year
      R: function R(date, token) {
        var isoWeekYear = (0, _index3.default)(date);
        return (0, _index6.default)(isoWeekYear, token.length);
      },
      // Extended year. This is a single number designating the year of this calendar system.
      // The main difference between `y` and `u` localizers are B.C. years:
      // | Year | `y` | `u` |
      // |------|-----|-----|
      // | AC 1 |   1 |   1 |
      // | BC 1 |   1 |   0 |
      // | BC 2 |   2 |  -1 |
      // Also `yy` always returns the last two digits of a year,
      // while `uu` pads single digit years to 2 characters and returns other years unchanged.
      u: function u(date, token) {
        var year = date.getUTCFullYear();
        return (0, _index6.default)(year, token.length);
      },
      // Quarter
      Q: function Q(date, token, localize) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
        switch (token) {
          // 1, 2, 3, 4
          case "Q":
            return String(quarter);
          // 01, 02, 03, 04
          case "QQ":
            return (0, _index6.default)(quarter, 2);
          // 1st, 2nd, 3rd, 4th
          case "Qo":
            return localize.ordinalNumber(quarter, {
              unit: "quarter"
            });
          // Q1, Q2, Q3, Q4
          case "QQQ":
            return localize.quarter(quarter, {
              width: "abbreviated",
              context: "formatting"
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)
          case "QQQQQ":
            return localize.quarter(quarter, {
              width: "narrow",
              context: "formatting"
            });
          // 1st quarter, 2nd quarter, ...
          case "QQQQ":
          default:
            return localize.quarter(quarter, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Stand-alone quarter
      q: function q(date, token, localize) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
        switch (token) {
          // 1, 2, 3, 4
          case "q":
            return String(quarter);
          // 01, 02, 03, 04
          case "qq":
            return (0, _index6.default)(quarter, 2);
          // 1st, 2nd, 3rd, 4th
          case "qo":
            return localize.ordinalNumber(quarter, {
              unit: "quarter"
            });
          // Q1, Q2, Q3, Q4
          case "qqq":
            return localize.quarter(quarter, {
              width: "abbreviated",
              context: "standalone"
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)
          case "qqqqq":
            return localize.quarter(quarter, {
              width: "narrow",
              context: "standalone"
            });
          // 1st quarter, 2nd quarter, ...
          case "qqqq":
          default:
            return localize.quarter(quarter, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      // Month
      M: function M(date, token, localize) {
        var month = date.getUTCMonth();
        switch (token) {
          case "M":
          case "MM":
            return _index7.default.M(date, token);
          // 1st, 2nd, ..., 12th
          case "Mo":
            return localize.ordinalNumber(month + 1, {
              unit: "month"
            });
          // Jan, Feb, ..., Dec
          case "MMM":
            return localize.month(month, {
              width: "abbreviated",
              context: "formatting"
            });
          // J, F, ..., D
          case "MMMMM":
            return localize.month(month, {
              width: "narrow",
              context: "formatting"
            });
          // January, February, ..., December
          case "MMMM":
          default:
            return localize.month(month, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Stand-alone month
      L: function L(date, token, localize) {
        var month = date.getUTCMonth();
        switch (token) {
          // 1, 2, ..., 12
          case "L":
            return String(month + 1);
          // 01, 02, ..., 12
          case "LL":
            return (0, _index6.default)(month + 1, 2);
          // 1st, 2nd, ..., 12th
          case "Lo":
            return localize.ordinalNumber(month + 1, {
              unit: "month"
            });
          // Jan, Feb, ..., Dec
          case "LLL":
            return localize.month(month, {
              width: "abbreviated",
              context: "standalone"
            });
          // J, F, ..., D
          case "LLLLL":
            return localize.month(month, {
              width: "narrow",
              context: "standalone"
            });
          // January, February, ..., December
          case "LLLL":
          default:
            return localize.month(month, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      // Local week of year
      w: function w(date, token, localize, options) {
        var week = (0, _index4.default)(date, options);
        if (token === "wo") {
          return localize.ordinalNumber(week, {
            unit: "week"
          });
        }
        return (0, _index6.default)(week, token.length);
      },
      // ISO week of year
      I: function I(date, token, localize) {
        var isoWeek = (0, _index2.default)(date);
        if (token === "Io") {
          return localize.ordinalNumber(isoWeek, {
            unit: "week"
          });
        }
        return (0, _index6.default)(isoWeek, token.length);
      },
      // Day of the month
      d: function d(date, token, localize) {
        if (token === "do") {
          return localize.ordinalNumber(date.getUTCDate(), {
            unit: "date"
          });
        }
        return _index7.default.d(date, token);
      },
      // Day of year
      D: function D(date, token, localize) {
        var dayOfYear = (0, _index.default)(date);
        if (token === "Do") {
          return localize.ordinalNumber(dayOfYear, {
            unit: "dayOfYear"
          });
        }
        return (0, _index6.default)(dayOfYear, token.length);
      },
      // Day of week
      E: function E(date, token, localize) {
        var dayOfWeek = date.getUTCDay();
        switch (token) {
          // Tue
          case "E":
          case "EE":
          case "EEE":
            return localize.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          // T
          case "EEEEE":
            return localize.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          // Tu
          case "EEEEEE":
            return localize.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          // Tuesday
          case "EEEE":
          default:
            return localize.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Local day of week
      e: function e(date, token, localize, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch (token) {
          // Numerical value (Nth day of week with current locale or weekStartsOn)
          case "e":
            return String(localDayOfWeek);
          // Padded numerical value
          case "ee":
            return (0, _index6.default)(localDayOfWeek, 2);
          // 1st, 2nd, ..., 7th
          case "eo":
            return localize.ordinalNumber(localDayOfWeek, {
              unit: "day"
            });
          case "eee":
            return localize.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          // T
          case "eeeee":
            return localize.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          // Tu
          case "eeeeee":
            return localize.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          // Tuesday
          case "eeee":
          default:
            return localize.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Stand-alone local day of week
      c: function c(date, token, localize, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch (token) {
          // Numerical value (same as in `e`)
          case "c":
            return String(localDayOfWeek);
          // Padded numerical value
          case "cc":
            return (0, _index6.default)(localDayOfWeek, token.length);
          // 1st, 2nd, ..., 7th
          case "co":
            return localize.ordinalNumber(localDayOfWeek, {
              unit: "day"
            });
          case "ccc":
            return localize.day(dayOfWeek, {
              width: "abbreviated",
              context: "standalone"
            });
          // T
          case "ccccc":
            return localize.day(dayOfWeek, {
              width: "narrow",
              context: "standalone"
            });
          // Tu
          case "cccccc":
            return localize.day(dayOfWeek, {
              width: "short",
              context: "standalone"
            });
          // Tuesday
          case "cccc":
          default:
            return localize.day(dayOfWeek, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      // ISO day of week
      i: function i(date, token, localize) {
        var dayOfWeek = date.getUTCDay();
        var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
        switch (token) {
          // 2
          case "i":
            return String(isoDayOfWeek);
          // 02
          case "ii":
            return (0, _index6.default)(isoDayOfWeek, token.length);
          // 2nd
          case "io":
            return localize.ordinalNumber(isoDayOfWeek, {
              unit: "day"
            });
          // Tue
          case "iii":
            return localize.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          // T
          case "iiiii":
            return localize.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          // Tu
          case "iiiiii":
            return localize.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          // Tuesday
          case "iiii":
          default:
            return localize.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // AM or PM
      a: function a(date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        switch (token) {
          case "a":
          case "aa":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "aaa":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            }).toLowerCase();
          case "aaaaa":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "aaaa":
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // AM, PM, midnight, noon
      b: function b(date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;
        if (hours === 12) {
          dayPeriodEnumValue = dayPeriodEnum.noon;
        } else if (hours === 0) {
          dayPeriodEnumValue = dayPeriodEnum.midnight;
        } else {
          dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        }
        switch (token) {
          case "b":
          case "bb":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "bbb":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            }).toLowerCase();
          case "bbbbb":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "bbbb":
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // in the morning, in the afternoon, in the evening, at night
      B: function B(date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;
        if (hours >= 17) {
          dayPeriodEnumValue = dayPeriodEnum.evening;
        } else if (hours >= 12) {
          dayPeriodEnumValue = dayPeriodEnum.afternoon;
        } else if (hours >= 4) {
          dayPeriodEnumValue = dayPeriodEnum.morning;
        } else {
          dayPeriodEnumValue = dayPeriodEnum.night;
        }
        switch (token) {
          case "B":
          case "BB":
          case "BBB":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "BBBBB":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "BBBB":
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Hour [1-12]
      h: function h(date, token, localize) {
        if (token === "ho") {
          var hours = date.getUTCHours() % 12;
          if (hours === 0) hours = 12;
          return localize.ordinalNumber(hours, {
            unit: "hour"
          });
        }
        return _index7.default.h(date, token);
      },
      // Hour [0-23]
      H: function H(date, token, localize) {
        if (token === "Ho") {
          return localize.ordinalNumber(date.getUTCHours(), {
            unit: "hour"
          });
        }
        return _index7.default.H(date, token);
      },
      // Hour [0-11]
      K: function K(date, token, localize) {
        var hours = date.getUTCHours() % 12;
        if (token === "Ko") {
          return localize.ordinalNumber(hours, {
            unit: "hour"
          });
        }
        return (0, _index6.default)(hours, token.length);
      },
      // Hour [1-24]
      k: function k(date, token, localize) {
        var hours = date.getUTCHours();
        if (hours === 0) hours = 24;
        if (token === "ko") {
          return localize.ordinalNumber(hours, {
            unit: "hour"
          });
        }
        return (0, _index6.default)(hours, token.length);
      },
      // Minute
      m: function m(date, token, localize) {
        if (token === "mo") {
          return localize.ordinalNumber(date.getUTCMinutes(), {
            unit: "minute"
          });
        }
        return _index7.default.m(date, token);
      },
      // Second
      s: function s(date, token, localize) {
        if (token === "so") {
          return localize.ordinalNumber(date.getUTCSeconds(), {
            unit: "second"
          });
        }
        return _index7.default.s(date, token);
      },
      // Fraction of second
      S: function S(date, token) {
        return _index7.default.S(date, token);
      },
      // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
      X: function X(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        if (timezoneOffset === 0) {
          return "Z";
        }
        switch (token) {
          // Hours and optional minutes
          case "X":
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          // Hours, minutes and optional seconds without `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `XX`
          case "XXXX":
          case "XX":
            return formatTimezone(timezoneOffset);
          // Hours, minutes and optional seconds with `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `XXX`
          case "XXXXX":
          case "XXX":
          // Hours and minutes with `:` delimiter
          default:
            return formatTimezone(timezoneOffset, ":");
        }
      },
      // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
      x: function x(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch (token) {
          // Hours and optional minutes
          case "x":
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          // Hours, minutes and optional seconds without `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `xx`
          case "xxxx":
          case "xx":
            return formatTimezone(timezoneOffset);
          // Hours, minutes and optional seconds with `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `xxx`
          case "xxxxx":
          case "xxx":
          // Hours and minutes with `:` delimiter
          default:
            return formatTimezone(timezoneOffset, ":");
        }
      },
      // Timezone (GMT)
      O: function O(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch (token) {
          // Short
          case "O":
          case "OO":
          case "OOO":
            return "GMT" + formatTimezoneShort(timezoneOffset, ":");
          // Long
          case "OOOO":
          default:
            return "GMT" + formatTimezone(timezoneOffset, ":");
        }
      },
      // Timezone (specific non-location)
      z: function z(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch (token) {
          // Short
          case "z":
          case "zz":
          case "zzz":
            return "GMT" + formatTimezoneShort(timezoneOffset, ":");
          // Long
          case "zzzz":
          default:
            return "GMT" + formatTimezone(timezoneOffset, ":");
        }
      },
      // Seconds timestamp
      t: function t(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = Math.floor(originalDate.getTime() / 1e3);
        return (0, _index6.default)(timestamp, token.length);
      },
      // Milliseconds timestamp
      T: function T(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = originalDate.getTime();
        return (0, _index6.default)(timestamp, token.length);
      }
    };
    function formatTimezoneShort(offset, dirtyDelimiter) {
      var sign = offset > 0 ? "-" : "+";
      var absOffset = Math.abs(offset);
      var hours = Math.floor(absOffset / 60);
      var minutes = absOffset % 60;
      if (minutes === 0) {
        return sign + String(hours);
      }
      var delimiter = dirtyDelimiter || "";
      return sign + String(hours) + delimiter + (0, _index6.default)(minutes, 2);
    }
    function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
      if (offset % 60 === 0) {
        var sign = offset > 0 ? "-" : "+";
        return sign + (0, _index6.default)(Math.abs(offset) / 60, 2);
      }
      return formatTimezone(offset, dirtyDelimiter);
    }
    function formatTimezone(offset, dirtyDelimiter) {
      var delimiter = dirtyDelimiter || "";
      var sign = offset > 0 ? "-" : "+";
      var absOffset = Math.abs(offset);
      var hours = (0, _index6.default)(Math.floor(absOffset / 60), 2);
      var minutes = (0, _index6.default)(absOffset % 60, 2);
      return sign + hours + delimiter + minutes;
    }
    var _default = formatters;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/format/longFormatters/index.js
var require_longFormatters = __commonJS({
  "node_modules/date-fns/_lib/format/longFormatters/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var dateLongFormatter = function dateLongFormatter2(pattern, formatLong) {
      switch (pattern) {
        case "P":
          return formatLong.date({
            width: "short"
          });
        case "PP":
          return formatLong.date({
            width: "medium"
          });
        case "PPP":
          return formatLong.date({
            width: "long"
          });
        case "PPPP":
        default:
          return formatLong.date({
            width: "full"
          });
      }
    };
    var timeLongFormatter = function timeLongFormatter2(pattern, formatLong) {
      switch (pattern) {
        case "p":
          return formatLong.time({
            width: "short"
          });
        case "pp":
          return formatLong.time({
            width: "medium"
          });
        case "ppp":
          return formatLong.time({
            width: "long"
          });
        case "pppp":
        default:
          return formatLong.time({
            width: "full"
          });
      }
    };
    var dateTimeLongFormatter = function dateTimeLongFormatter2(pattern, formatLong) {
      var matchResult = pattern.match(/(P+)(p+)?/) || [];
      var datePattern = matchResult[1];
      var timePattern = matchResult[2];
      if (!timePattern) {
        return dateLongFormatter(pattern, formatLong);
      }
      var dateTimeFormat;
      switch (datePattern) {
        case "P":
          dateTimeFormat = formatLong.dateTime({
            width: "short"
          });
          break;
        case "PP":
          dateTimeFormat = formatLong.dateTime({
            width: "medium"
          });
          break;
        case "PPP":
          dateTimeFormat = formatLong.dateTime({
            width: "long"
          });
          break;
        case "PPPP":
        default:
          dateTimeFormat = formatLong.dateTime({
            width: "full"
          });
          break;
      }
      return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong)).replace("{{time}}", timeLongFormatter(timePattern, formatLong));
    };
    var longFormatters = {
      p: timeLongFormatter,
      P: dateTimeLongFormatter
    };
    var _default = longFormatters;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds/index.js
var require_getTimezoneOffsetInMilliseconds = __commonJS({
  "node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getTimezoneOffsetInMilliseconds2;
    function getTimezoneOffsetInMilliseconds2(date) {
      var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
      utcDate.setUTCFullYear(date.getFullYear());
      return date.getTime() - utcDate.getTime();
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/protectedTokens/index.js
var require_protectedTokens = __commonJS({
  "node_modules/date-fns/_lib/protectedTokens/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isProtectedDayOfYearToken = isProtectedDayOfYearToken;
    exports.isProtectedWeekYearToken = isProtectedWeekYearToken;
    exports.throwProtectedError = throwProtectedError;
    var protectedDayOfYearTokens = ["D", "DD"];
    var protectedWeekYearTokens = ["YY", "YYYY"];
    function isProtectedDayOfYearToken(token) {
      return protectedDayOfYearTokens.indexOf(token) !== -1;
    }
    function isProtectedWeekYearToken(token) {
      return protectedWeekYearTokens.indexOf(token) !== -1;
    }
    function throwProtectedError(token, format2, input) {
      if (token === "YYYY") {
        throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === "YY") {
        throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === "D") {
        throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === "DD") {
        throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      }
    }
  }
});

// node_modules/date-fns/locale/en-US/_lib/formatDistance/index.js
var require_formatDistance = __commonJS({
  "node_modules/date-fns/locale/en-US/_lib/formatDistance/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var formatDistanceLocale = {
      lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
      },
      xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
      },
      halfAMinute: "half a minute",
      lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
      },
      xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
      },
      aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
      },
      xHours: {
        one: "1 hour",
        other: "{{count}} hours"
      },
      xDays: {
        one: "1 day",
        other: "{{count}} days"
      },
      aboutXWeeks: {
        one: "about 1 week",
        other: "about {{count}} weeks"
      },
      xWeeks: {
        one: "1 week",
        other: "{{count}} weeks"
      },
      aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
      },
      xMonths: {
        one: "1 month",
        other: "{{count}} months"
      },
      aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
      },
      xYears: {
        one: "1 year",
        other: "{{count}} years"
      },
      overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
      },
      almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
      }
    };
    var formatDistance = function formatDistance2(token, count, options) {
      var result;
      var tokenValue = formatDistanceLocale[token];
      if (typeof tokenValue === "string") {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace("{{count}}", count.toString());
      }
      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return "in " + result;
        } else {
          return result + " ago";
        }
      }
      return result;
    };
    var _default = formatDistance;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// node_modules/date-fns/locale/_lib/buildFormatLongFn/index.js
var require_buildFormatLongFn = __commonJS({
  "node_modules/date-fns/locale/_lib/buildFormatLongFn/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = buildFormatLongFn;
    function buildFormatLongFn(args) {
      return function() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var width = options.width ? String(options.width) : args.defaultWidth;
        var format2 = args.formats[width] || args.formats[args.defaultWidth];
        return format2;
      };
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/locale/en-US/_lib/formatLong/index.js
var require_formatLong = __commonJS({
  "node_modules/date-fns/locale/en-US/_lib/formatLong/index.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = _interopRequireDefault(require_buildFormatLongFn());
    var dateFormats = {
      full: "EEEE, MMMM do, y",
      long: "MMMM do, y",
      medium: "MMM d, y",
      short: "MM/dd/yyyy"
    };
    var timeFormats = {
      full: "h:mm:ss a zzzz",
      long: "h:mm:ss a z",
      medium: "h:mm:ss a",
      short: "h:mm a"
    };
    var dateTimeFormats = {
      full: "{{date}} 'at' {{time}}",
      long: "{{date}} 'at' {{time}}",
      medium: "{{date}}, {{time}}",
      short: "{{date}}, {{time}}"
    };
    var formatLong = {
      date: (0, _index.default)({
        formats: dateFormats,
        defaultWidth: "full"
      }),
      time: (0, _index.default)({
        formats: timeFormats,
        defaultWidth: "full"
      }),
      dateTime: (0, _index.default)({
        formats: dateTimeFormats,
        defaultWidth: "full"
      })
    };
    var _default = formatLong;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// node_modules/date-fns/locale/en-US/_lib/formatRelative/index.js
var require_formatRelative = __commonJS({
  "node_modules/date-fns/locale/en-US/_lib/formatRelative/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var formatRelativeLocale = {
      lastWeek: "'last' eeee 'at' p",
      yesterday: "'yesterday at' p",
      today: "'today at' p",
      tomorrow: "'tomorrow at' p",
      nextWeek: "eeee 'at' p",
      other: "P"
    };
    var formatRelative = function formatRelative2(token, _date, _baseDate, _options) {
      return formatRelativeLocale[token];
    };
    var _default = formatRelative;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// node_modules/date-fns/locale/_lib/buildLocalizeFn/index.js
var require_buildLocalizeFn = __commonJS({
  "node_modules/date-fns/locale/_lib/buildLocalizeFn/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = buildLocalizeFn;
    function buildLocalizeFn(args) {
      return function(dirtyIndex, options) {
        var context = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
        var valuesArray;
        if (context === "formatting" && args.formattingValues) {
          var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
          var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
          valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
        } else {
          var _defaultWidth = args.defaultWidth;
          var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
          valuesArray = args.values[_width] || args.values[_defaultWidth];
        }
        var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
        return valuesArray[index];
      };
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/locale/en-US/_lib/localize/index.js
var require_localize = __commonJS({
  "node_modules/date-fns/locale/en-US/_lib/localize/index.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = _interopRequireDefault(require_buildLocalizeFn());
    var eraValues = {
      narrow: ["B", "A"],
      abbreviated: ["BC", "AD"],
      wide: ["Before Christ", "Anno Domini"]
    };
    var quarterValues = {
      narrow: ["1", "2", "3", "4"],
      abbreviated: ["Q1", "Q2", "Q3", "Q4"],
      wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
    };
    var monthValues = {
      narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
      abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
    };
    var dayValues = {
      narrow: ["S", "M", "T", "W", "T", "F", "S"],
      short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
      abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    };
    var dayPeriodValues = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      }
    };
    var formattingDayPeriodValues = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      }
    };
    var ordinalNumber = function ordinalNumber2(dirtyNumber, _options) {
      var number = Number(dirtyNumber);
      var rem100 = number % 100;
      if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
          case 1:
            return number + "st";
          case 2:
            return number + "nd";
          case 3:
            return number + "rd";
        }
      }
      return number + "th";
    };
    var localize = {
      ordinalNumber,
      era: (0, _index.default)({
        values: eraValues,
        defaultWidth: "wide"
      }),
      quarter: (0, _index.default)({
        values: quarterValues,
        defaultWidth: "wide",
        argumentCallback: function argumentCallback(quarter) {
          return quarter - 1;
        }
      }),
      month: (0, _index.default)({
        values: monthValues,
        defaultWidth: "wide"
      }),
      day: (0, _index.default)({
        values: dayValues,
        defaultWidth: "wide"
      }),
      dayPeriod: (0, _index.default)({
        values: dayPeriodValues,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: "wide"
      })
    };
    var _default = localize;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// node_modules/date-fns/locale/_lib/buildMatchFn/index.js
var require_buildMatchFn = __commonJS({
  "node_modules/date-fns/locale/_lib/buildMatchFn/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = buildMatchFn;
    function buildMatchFn(args) {
      return function(string) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var width = options.width;
        var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
        var matchResult = string.match(matchPattern);
        if (!matchResult) {
          return null;
        }
        var matchedString = matchResult[0];
        var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
        var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
          return pattern.test(matchedString);
        }) : findKey(parsePatterns, function(pattern) {
          return pattern.test(matchedString);
        });
        var value;
        value = args.valueCallback ? args.valueCallback(key) : key;
        value = options.valueCallback ? options.valueCallback(value) : value;
        var rest = string.slice(matchedString.length);
        return {
          value,
          rest
        };
      };
    }
    function findKey(object, predicate) {
      for (var key in object) {
        if (object.hasOwnProperty(key) && predicate(object[key])) {
          return key;
        }
      }
      return void 0;
    }
    function findIndex(array, predicate) {
      for (var key = 0; key < array.length; key++) {
        if (predicate(array[key])) {
          return key;
        }
      }
      return void 0;
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/locale/_lib/buildMatchPatternFn/index.js
var require_buildMatchPatternFn = __commonJS({
  "node_modules/date-fns/locale/_lib/buildMatchPatternFn/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = buildMatchPatternFn;
    function buildMatchPatternFn(args) {
      return function(string) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var matchResult = string.match(args.matchPattern);
        if (!matchResult) return null;
        var matchedString = matchResult[0];
        var parseResult = string.match(args.parsePattern);
        if (!parseResult) return null;
        var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
        value = options.valueCallback ? options.valueCallback(value) : value;
        var rest = string.slice(matchedString.length);
        return {
          value,
          rest
        };
      };
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/locale/en-US/_lib/match/index.js
var require_match = __commonJS({
  "node_modules/date-fns/locale/en-US/_lib/match/index.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = _interopRequireDefault(require_buildMatchFn());
    var _index2 = _interopRequireDefault(require_buildMatchPatternFn());
    var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
    var parseOrdinalNumberPattern = /\d+/i;
    var matchEraPatterns = {
      narrow: /^(b|a)/i,
      abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
      wide: /^(before christ|before common era|anno domini|common era)/i
    };
    var parseEraPatterns = {
      any: [/^b/i, /^(a|c)/i]
    };
    var matchQuarterPatterns = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](th|st|nd|rd)? quarter/i
    };
    var parseQuarterPatterns = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
      wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    };
    var parseMonthPatterns = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns = {
      narrow: /^[smtwf]/i,
      short: /^(su|mo|tu|we|th|fr|sa)/i,
      abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
      wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    };
    var parseDayPatterns = {
      narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
      any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    };
    var matchDayPeriodPatterns = {
      narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
      any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    };
    var parseDayPeriodPatterns = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
      }
    };
    var match = {
      ordinalNumber: (0, _index2.default)({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: function valueCallback(value) {
          return parseInt(value, 10);
        }
      }),
      era: (0, _index.default)({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns,
        defaultParseWidth: "any"
      }),
      quarter: (0, _index.default)({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: "any",
        valueCallback: function valueCallback(index) {
          return index + 1;
        }
      }),
      month: (0, _index.default)({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: "any"
      }),
      day: (0, _index.default)({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns,
        defaultParseWidth: "any"
      }),
      dayPeriod: (0, _index.default)({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: "any"
      })
    };
    var _default = match;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// node_modules/date-fns/locale/en-US/index.js
var require_en_US = __commonJS({
  "node_modules/date-fns/locale/en-US/index.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = _interopRequireDefault(require_formatDistance());
    var _index2 = _interopRequireDefault(require_formatLong());
    var _index3 = _interopRequireDefault(require_formatRelative());
    var _index4 = _interopRequireDefault(require_localize());
    var _index5 = _interopRequireDefault(require_match());
    var locale = {
      code: "en-US",
      formatDistance: _index.default,
      formatLong: _index2.default,
      formatRelative: _index3.default,
      localize: _index4.default,
      match: _index5.default,
      options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
      }
    };
    var _default = locale;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/defaultLocale/index.js
var require_defaultLocale = __commonJS({
  "node_modules/date-fns/_lib/defaultLocale/index.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = _interopRequireDefault(require_en_US());
    var _default = _index.default;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// node_modules/date-fns/format/index.js
var require_format = __commonJS({
  "node_modules/date-fns/format/index.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = format2;
    var _index = _interopRequireDefault(require_isValid());
    var _index2 = _interopRequireDefault(require_subMilliseconds());
    var _index3 = _interopRequireDefault(require_toDate());
    var _index4 = _interopRequireDefault(require_formatters());
    var _index5 = _interopRequireDefault(require_longFormatters());
    var _index6 = _interopRequireDefault(require_getTimezoneOffsetInMilliseconds());
    var _index7 = require_protectedTokens();
    var _index8 = _interopRequireDefault(require_toInteger());
    var _index9 = _interopRequireDefault(require_requiredArgs());
    var _index10 = require_defaultOptions();
    var _index11 = _interopRequireDefault(require_defaultLocale());
    var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
    var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    var escapedStringRegExp = /^'([^]*?)'?$/;
    var doubleQuoteRegExp = /''/g;
    var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
    function format2(dirtyDate, dirtyFormatStr, options) {
      var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
      (0, _index9.default)(2, arguments);
      var formatStr = String(dirtyFormatStr);
      var defaultOptions2 = (0, _index10.getDefaultOptions)();
      var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : _index11.default;
      var firstWeekContainsDate = (0, _index8.default)((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
      }
      var weekStartsOn = (0, _index8.default)((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
      }
      if (!locale.localize) {
        throw new RangeError("locale must contain localize property");
      }
      if (!locale.formatLong) {
        throw new RangeError("locale must contain formatLong property");
      }
      var originalDate = (0, _index3.default)(dirtyDate);
      if (!(0, _index.default)(originalDate)) {
        throw new RangeError("Invalid time value");
      }
      var timezoneOffset = (0, _index6.default)(originalDate);
      var utcDate = (0, _index2.default)(originalDate, timezoneOffset);
      var formatterOptions = {
        firstWeekContainsDate,
        weekStartsOn,
        locale,
        _originalDate: originalDate
      };
      var result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
        var firstCharacter = substring[0];
        if (firstCharacter === "p" || firstCharacter === "P") {
          var longFormatter = _index5.default[firstCharacter];
          return longFormatter(substring, locale.formatLong);
        }
        return substring;
      }).join("").match(formattingTokensRegExp).map(function(substring) {
        if (substring === "''") {
          return "'";
        }
        var firstCharacter = substring[0];
        if (firstCharacter === "'") {
          return cleanEscapedString(substring);
        }
        var formatter = _index4.default[firstCharacter];
        if (formatter) {
          if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && (0, _index7.isProtectedWeekYearToken)(substring)) {
            (0, _index7.throwProtectedError)(substring, dirtyFormatStr, String(dirtyDate));
          }
          if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && (0, _index7.isProtectedDayOfYearToken)(substring)) {
            (0, _index7.throwProtectedError)(substring, dirtyFormatStr, String(dirtyDate));
          }
          return formatter(utcDate, substring, locale.localize, formatterOptions);
        }
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
        }
        return substring;
      }).join("");
      return result;
    }
    function cleanEscapedString(input) {
      var matched = input.match(escapedStringRegExp);
      if (!matched) {
        return input;
      }
      return matched[1].replace(doubleQuoteRegExp, "'");
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/assign/index.js
var require_assign = __commonJS({
  "node_modules/date-fns/_lib/assign/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = assign;
    function assign(target, object) {
      if (target == null) {
        throw new TypeError("assign requires that input parameter not be null or undefined");
      }
      for (var property in object) {
        if (Object.prototype.hasOwnProperty.call(object, property)) {
          ;
          target[property] = object[property];
        }
      }
      return target;
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/cloneObject/index.js
var require_cloneObject = __commonJS({
  "node_modules/date-fns/_lib/cloneObject/index.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cloneObject3;
    var _index = _interopRequireDefault(require_assign());
    function cloneObject3(object) {
      return (0, _index.default)({}, object);
    }
    module.exports = exports.default;
  }
});

// node_modules/bail/index.js
function bail(error) {
  if (error) {
    throw error;
  }
}

// node_modules/unified/lib/index.js
var import_extend = __toESM(require_extend(), 1);

// node_modules/is-plain-obj/index.js
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// node_modules/trough/lib/index.js
function trough() {
  const fns = [];
  const pipeline = { run, use };
  return pipeline;
  function run(...values) {
    let middlewareIndex = -1;
    const callback = values.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next(null, ...values);
    function next(error, ...output) {
      const fn = fns[++middlewareIndex];
      let index = -1;
      if (error) {
        callback(error);
        return;
      }
      while (++index < values.length) {
        if (output[index] === null || output[index] === void 0) {
          output[index] = values[index];
        }
      }
      values = output;
      if (fn) {
        wrap(fn, next)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware.apply(this, parameters);
    } catch (error) {
      const exception = (
        /** @type {Error} */
        error
      );
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result && result.then && typeof result.then === "function") {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error, ...output) {
    if (!called) {
      called = true;
      callback(error, ...output);
    }
  }
  function then(value) {
    done(null, value);
  }
}

// node_modules/unified/lib/callable-instance.js
var CallableInstance = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  (function(property) {
    const self = this;
    const constr = self.constructor;
    const proto = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      constr.prototype
    );
    const value = proto[property];
    const apply = function() {
      return value.apply(apply, arguments);
    };
    Object.setPrototypeOf(apply, proto);
    return apply;
  })
);

// node_modules/unified/lib/index.js
var own = {}.hasOwnProperty;
var Processor = class _Processor extends CallableInstance {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy");
    this.Compiler = void 0;
    this.Parser = void 0;
    this.attachers = [];
    this.compiler = void 0;
    this.freezeIndex = -1;
    this.frozen = void 0;
    this.namespace = {};
    this.parser = void 0;
    this.transformers = trough();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const destination = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new _Processor()
    );
    let index = -1;
    while (++index < this.attachers.length) {
      const attacher = this.attachers[index];
      destination.use(...attacher);
    }
    destination.data((0, import_extend.default)(true, {}, this.namespace));
    return destination;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(key, value) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", this.frozen);
        this.namespace[key] = value;
        return this;
      }
      return own.call(this.namespace, key) && this.namespace[key] || void 0;
    }
    if (key) {
      assertUnfrozen("data", this.frozen);
      this.namespace = key;
      return this;
    }
    return this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * It’s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen) {
      return this;
    }
    const self = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    while (++this.freezeIndex < this.attachers.length) {
      const [attacher, ...options] = this.attachers[this.freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(self, ...options);
      if (typeof transformer === "function") {
        this.transformers.use(transformer);
      }
    }
    this.frozen = true;
    this.freezeIndex = Number.POSITIVE_INFINITY;
    return this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(file) {
    this.freeze();
    const realFile = vfile(file);
    const parser2 = this.parser || this.Parser;
    assertParser("parse", parser2);
    return parser2(String(realFile), realFile);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(file, done) {
    const self = this;
    this.freeze();
    assertParser("process", this.parser || this.Parser);
    assertCompiler("process", this.compiler || this.Compiler);
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      const realFile = vfile(file);
      const parseTree = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        self.parse(realFile)
      );
      self.run(parseTree, realFile, function(error, tree, file2) {
        if (error || !tree || !file2) {
          return realDone(error);
        }
        const compileTree = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          tree
        );
        const compileResult = self.stringify(compileTree, file2);
        if (looksLikeAValue(compileResult)) {
          file2.value = compileResult;
        } else {
          file2.result = compileResult;
        }
        realDone(
          error,
          /** @type {VFileWithOutput<CompileResult>} */
          file2
        );
      });
      function realDone(error, file2) {
        if (error || !file2) {
          reject(error);
        } else if (resolve) {
          resolve(file2);
        } else {
          ok(done, "`done` is defined if `resolve` is not");
          done(void 0, file2);
        }
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(file) {
    let complete = false;
    let result;
    this.freeze();
    assertParser("processSync", this.parser || this.Parser);
    assertCompiler("processSync", this.compiler || this.Compiler);
    this.process(file, realDone);
    assertDone("processSync", "process", complete);
    ok(result, "we either bailed on an error or have a tree");
    return result;
    function realDone(error, file2) {
      complete = true;
      bail(error);
      result = file2;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(tree, file, done) {
    assertNode(tree);
    this.freeze();
    const transformers = this.transformers;
    if (!done && typeof file === "function") {
      done = file;
      file = void 0;
    }
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      ok(
        typeof file !== "function",
        "`file` can’t be a `done` anymore, we checked"
      );
      const realFile = vfile(file);
      transformers.run(tree, realFile, realDone);
      function realDone(error, outputTree, file2) {
        const resultingTree = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          outputTree || tree
        );
        if (error) {
          reject(error);
        } else if (resolve) {
          resolve(resultingTree);
        } else {
          ok(done, "`done` is defined if `resolve` is not");
          done(void 0, resultingTree, file2);
        }
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(tree, file) {
    let complete = false;
    let result;
    this.run(tree, file, realDone);
    assertDone("runSync", "run", complete);
    ok(result, "we either bailed on an error or have a tree");
    return result;
    function realDone(error, tree2) {
      bail(error);
      result = tree2;
      complete = true;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(tree, file) {
    this.freeze();
    const realFile = vfile(file);
    const compiler = this.compiler || this.Compiler;
    assertCompiler("stringify", compiler);
    assertNode(tree);
    return compiler(tree, realFile);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(value, ...parameters) {
    const attachers = this.attachers;
    const namespace = this.namespace;
    assertUnfrozen("use", this.frozen);
    if (value === null || value === void 0) {
    } else if (typeof value === "function") {
      addPlugin(value, parameters);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    return this;
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2, []);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...parameters2] = (
            /** @type {PluginTuple<Array<unknown>>} */
            value2
          );
          addPlugin(plugin, parameters2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      if (!("plugins" in result) && !("settings" in result)) {
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      }
      addList(result.plugins);
      if (result.settings) {
        namespace.settings = (0, import_extend.default)(true, namespace.settings, result.settings);
      }
    }
    function addList(plugins) {
      let index = -1;
      if (plugins === null || plugins === void 0) {
      } else if (Array.isArray(plugins)) {
        while (++index < plugins.length) {
          const thing = plugins[index];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, parameters2) {
      let index = -1;
      let entryIndex = -1;
      while (++index < attachers.length) {
        if (attachers[index][0] === plugin) {
          entryIndex = index;
          break;
        }
      }
      if (entryIndex === -1) {
        attachers.push([plugin, ...parameters2]);
      } else if (parameters2.length > 0) {
        let [primary, ...rest] = parameters2;
        const currentPrimary = attachers[entryIndex][1];
        if (isPlainObject(currentPrimary) && isPlainObject(primary)) {
          primary = (0, import_extend.default)(true, currentPrimary, primary);
        }
        attachers[entryIndex] = [plugin, primary, ...rest];
      }
    }
  }
};
var unified = new Processor().freeze();
function assertParser(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `parser`");
  }
}
function assertCompiler(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `compiler`");
  }
}
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node) {
  if (!isPlainObject(node) || typeof node.type !== "string") {
    throw new TypeError("Expected node, got `" + node + "`");
  }
}
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return Boolean(
    value && typeof value === "object" && "message" in value && "messages" in value
  );
}
function looksLikeAValue(value) {
  return typeof value === "string" || isUint8Array(value);
}
function isUint8Array(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}

// node_modules/orga/dist/options.js
function withDefault(options) {
  return {
    ...defaultOptions,
    ...options
  };
}
var defaultOptions = {
  todos: ["TODO | DONE"],
  timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
  flat: false
};

// node_modules/orga/dist/utils.js
var clone = (obj) => {
  return JSON.parse(JSON.stringify(obj));
};
var isPhrasingContent = (token) => {
  return token.type === "text" || token.type === "footnote.reference" || token.type === "opening" || token.type === "link" || token.type === "newline";
};

// node_modules/orga/dist/parse/block.js
var block = (begin, ctx) => {
  ctx.save();
  const contentStart = begin.position.end;
  const blockName = begin.name.toLowerCase();
  const block2 = ctx.enter({
    type: "block",
    name: begin.name,
    params: begin.params,
    value: "",
    attributes: { ...ctx.attributes },
    children: []
  });
  ctx.push(ctx.lexer.eat());
  const align = (content) => {
    let indent = -1;
    return content.trimEnd().split("\n").map((line) => {
      const _indent = line.search(/\S/);
      if (indent === -1) {
        indent = _indent;
      }
      if (indent === -1)
        return "";
      let result = line.substring(Math.min(_indent, indent));
      if (block2.name.toLowerCase() === "src" && block2.params[0] === "org") {
        result = result.replace(/^(\s*),/, "$1");
      }
      return result;
    }).join("\n").trim();
  };
  return {
    name: "block",
    rules: [
      {
        test: "block.end",
        action: (token, context) => {
          const lexer = context.lexer;
          if (token.name.toLowerCase() !== blockName)
            return "next";
          block2.value = align(lexer.substring({
            start: contentStart,
            end: token.position.start
          }));
          context.push(lexer.eat());
          context.exit("block");
          return "break";
        }
      },
      {
        test: ["stars", "EOF"],
        action: (_, context) => {
          context.restore();
          context.lexer.modify((t) => ({
            type: "text",
            value: context.lexer.substring(t.position),
            position: t.position
          }));
          return "break";
        }
      },
      { test: "newline", action: (_, { discard }) => discard() },
      { test: /./, action: (_, { consume }) => consume() }
    ]
  };
};
var block_default = block;

// node_modules/orga/dist/parse/latex.js
var latex = (begin, context) => {
  context.save();
  const contentStart = begin.position.start;
  const envName = begin.name.toLowerCase();
  const latexBlock = context.enter({
    type: "latex",
    name: begin.name,
    value: "",
    children: []
  });
  context.push(context.lexer.eat());
  const align = (content) => {
    let indent = -1;
    return content.trimEnd().split("\n").map((line) => {
      const _indent = line.search(/\S/);
      if (indent === -1) {
        indent = _indent;
      }
      if (indent === -1)
        return "";
      const result = line.substring(Math.min(_indent, indent));
      return result;
    }).join("\n").trim();
  };
  return {
    name: "latex",
    rules: [
      {
        test: "latex.end",
        action: (token, context2) => {
          if (token.name.toLowerCase() !== envName)
            return "next";
          latexBlock.value = align(context2.lexer.substring({
            start: contentStart,
            end: token.position.end
          }));
          context2.push(context2.lexer.eat());
          context2.lexer.eat("newline");
          context2.exit("latex");
          return "break";
        }
      },
      {
        test: ["stars", "EOF"],
        action: (_, context2) => {
          context2.restore();
          context2.lexer.modify((t) => ({
            type: "text",
            value: context2.lexer.substring(t.position),
            position: t.position
          }));
          return "break";
        }
      },
      { test: /./, action: (_, context2) => context2.push(context2.lexer.eat()) }
    ]
  };
};
var latex_default = latex;

// node_modules/orga/dist/types.js
function isSection(node) {
  return node.type === "section";
}
function isParagraph(node) {
  return node.type === "paragraph";
}
function isLink(node) {
  return node.type === "link";
}
function isFootnoteReference(node) {
  return node.type === "footnote.reference";
}

// node_modules/orga/dist/parse/context.js
function point(d) {
  return { ...d };
}
function createContext(lexer, options) {
  let stack = [];
  let snapshot = void 0;
  function enter(node) {
    const start = lexer.peek()?.position?.start || lexer.peek(-1)?.position?.end || { line: 1, column: 1, offset: 0 };
    node.position = { start: point(start) };
    stack.push(node);
    return node;
  }
  const tree = enter({
    type: "document",
    properties: {},
    children: []
  });
  const pop = () => {
    const node = stack.pop();
    const end = lexer.peek()?.position?.start || lexer.peek(-1)?.position?.end || { line: 1, column: 1, offset: 0 };
    node.position.end = point(end);
    if (!node) {
      throw new Error("unexpected empty stack");
    }
    if (stack.length > 0) {
      push(node);
    }
    return node;
  };
  function exit(predicate, strict = true) {
    if (stack.length === 0)
      return;
    const last = stack[stack.length - 1];
    if (test(last, predicate)) {
      return pop();
    }
    if (strict) {
      throw new Error(`
can not strictly exit ${predicate},
actual: ${last.type}
location: line: ${last.position.start.line}, column: ${last.position.start.column}
`.trim());
    }
  }
  function exitTo(predicate) {
    exitAll(not(predicate));
  }
  function exitAll(predicate) {
    if (exit(predicate, false)) {
      exitAll(predicate);
    }
  }
  function getLevel() {
    let index = stack.length - 1;
    while (index > 0) {
      const node = stack[index];
      if (isSection(node)) {
        return node.level;
      }
      index -= 1;
    }
    return 0;
  }
  const push = (node) => {
    if (!node)
      return;
    if (stack.length === 0) {
      throw new Error("unexpected empty stack");
    }
    const parent = stack[stack.length - 1];
    parent.children.push(node);
  };
  return {
    options,
    attributes: {},
    enter,
    exit,
    exitAll,
    exitTo,
    push,
    addProp: function(key, value) {
      const k = key.toLowerCase().trim();
      const v = value.trim();
      const existing = tree.properties[k];
      if (existing) {
        if (Array.isArray(existing)) {
          existing.push(v);
        }
        if (typeof existing === "string") {
          tree.properties[k] = [existing, v];
        }
      } else {
        tree.properties[k] = v;
      }
    },
    consume: function() {
      push(lexer.eat());
    },
    discard: function() {
      lexer.eat();
    },
    within: function(predicate) {
      return test(this.parent, predicate);
    },
    save: function() {
      const level = this.level;
      const attributes = this.attributes;
      snapshot = {
        stack: [...stack],
        level,
        attributes: { ...attributes },
        savePoint: lexer.save()
      };
    },
    restore: function() {
      if (snapshot === void 0)
        return;
      this.attributes = { ...snapshot.attributes };
      stack = [...snapshot.stack];
      lexer.restore(snapshot.savePoint);
    },
    get parent() {
      return stack[stack.length - 1];
    },
    get tree() {
      return tree;
    },
    get lexer() {
      return lexer;
    },
    get level() {
      return getLevel();
    },
    get state() {
      const token = lexer.peek();
      const lines = [`lexer: ${lexer.save()}`];
      lines.push(`token: ${token ? token.type : "EOF"}`);
      if (token) {
        lines.push(`content: ${lexer.substring(token.position)}`);
      }
      lines.push(`stack:   ${stack.map((n) => n.type).join(" > ")}`);
      return lines.join("\n");
    }
  };
}

// node_modules/orga/dist/parse/_primitive.js
var primitive_default = (value) => {
  const num = Number(value);
  if (!Number.isNaN(num))
    return num;
  if (value.toLowerCase() === "true")
    return true;
  if (value.toLowerCase() === "false")
    return false;
  return value;
};

// node_modules/orga/dist/parse/_parseSymbols.js
var parseSymbols_default = (text) => {
  let t = text;
  const result = {};
  while (t.length > 0) {
    const m = t.match(/^:\w+/);
    if (!m)
      break;
    const key = m[0].substring(1);
    t = t.slice(m[0].length);
    const end = t.match(/\s(:\w+)/);
    const index = end ? end.index + 1 : t.length;
    const value = t.substring(0, index).trim();
    t = t.slice(index);
    result[key] = primitive_default(value);
  }
  return result;
};

// node_modules/orga/dist/parse/keyword.js
var AFFILIATED_KEYWORDS = ["caption", "header", "name", "plot", "results"];
var keyword = (token, context) => {
  const { push, lexer, addProp } = context;
  const key = token.key.toLowerCase();
  const { value } = token;
  if (key === "html") {
    push({ type: "html", value, position: token.position });
  } else if (key === "jsx") {
    push({ type: "jsx", value, position: token.position });
  } else {
    if (AFFILIATED_KEYWORDS.includes(key)) {
      context.attributes[key] = primitive_default(value);
    } else if (key.startsWith("attr_")) {
      context.attributes[key] = {
        ...context.attributes[key],
        ...parseSymbols_default(value)
      };
    } else if (key === "todo") {
      lexer.addInBufferTodoKeywords(value);
    } else {
      addProp(key, value);
    }
    push(token);
  }
  lexer.eat();
};
var keyword_default = keyword;

// node_modules/orga/dist/parse/phrasing.js
var phrasingContent = {
  name: "inline",
  rules: [
    {
      test: "opening",
      action: (token, { enter, consume }) => {
        enter({
          type: token.element,
          children: []
        });
        consume();
      }
    },
    {
      test: "closing",
      action: (token, { exit, consume }) => {
        consume();
        exit(token.element);
      }
    },
    {
      test: "link.path",
      action: (token, context) => {
        const { parent, consume, attributes } = context;
        if (!isLink(parent)) {
          throw new Error("expect parent to be link");
        }
        parent.path = {
          protocol: token.protocol,
          value: token.value,
          search: token.search
        };
        parent.attributes = attributes;
        context.attributes = {};
        consume();
      }
    },
    {
      test: "footnote.label",
      action: (token, { parent, consume }) => {
        if (!isFootnoteReference(parent)) {
          throw new Error("expect parent to be footnote reference");
        }
        parent.label = token.label;
        consume();
      }
    },
    {
      test: "text",
      action: (_, { consume }) => {
        consume();
      }
    }
  ]
};
var phrasing_default = phrasingContent;

// node_modules/orga/dist/parse/list.js
var listItem = (token, { enter, consume }) => {
  const item = enter({
    type: "list.item",
    indent: token.indent,
    children: []
  });
  consume();
  return {
    name: "list item",
    rules: [
      {
        test: "emptyLine",
        action: (_, { exit, consume: consume2 }) => {
          consume2();
          exit(item.type);
          return "break";
        }
      },
      { test: "newline", action: (_, { consume: consume2 }) => consume2() },
      {
        test: "list.item.tag",
        action: (token2, { consume: consume2 }) => {
          item.tag = token2.value;
          consume2();
        }
      },
      {
        test: "list.item.checkbox",
        action: (_, { consume: consume2 }) => {
          consume2();
        }
      },
      { test: isPhrasingContent, action: phrasing_default },
      {
        test: /.*/,
        action: (_, { exit }) => {
          exit("list.item");
          return "break";
        }
      }
    ]
  };
};
var list = (token, context) => {
  context.enter({
    type: "list",
    indent: token.indent,
    ordered: token.ordered,
    children: [],
    attributes: context.attributes
  });
  context.attributes = {};
  const indent = token.indent;
  const handler = {
    name: "list",
    rules: [
      {
        test: "stars",
        action: (_, { exit }) => {
          exit("list");
          return "break";
        }
      },
      {
        test: ["emptyLine", "newline"],
        action: (_, { exit, consume }) => {
          consume();
          exit("list");
          return "break";
        }
      },
      {
        test: "list.item.bullet",
        action: (token2, context2) => {
          const { exit } = context2;
          if (indent > token2.indent) {
            exit("list");
            return "break";
          } else if (indent === token2.indent) {
            return listItem(token2, context2);
          } else {
            return list(token2, context2);
          }
        }
      },
      {
        test: /.*/,
        action: (_, { exit }) => {
          exit("list");
          return "break";
        }
      }
    ]
  };
  return handler;
};
var list_default = list;

// node_modules/orga/dist/parse/_utils.js
var COMMON_IMAGE_EXTENSIONS = [
  "apng",
  "avif",
  "gif",
  "jpeg",
  "jpg",
  "jfif",
  "pjpeg",
  "pjp",
  "png",
  "svg",
  "webp",
  "bmp",
  "ico",
  "cur",
  "tif",
  "tiff"
];
var isImage = (path) => {
  const ext = path.toLowerCase().split(".").pop();
  return COMMON_IMAGE_EXTENSIONS.includes(ext);
};

// node_modules/orga/dist/parse/paragraph.js
var isWhitespaces = (node) => {
  return node.type === "text" && node.value.trim().length === 0 || node.type === "newline" || node.type === "emptyLine";
};
var paragraph = () => {
  const makeSureParagraph = (context) => {
    const parent = context.parent;
    if (parent.type === "paragraph")
      return;
    context.save();
    context.enter({
      type: "paragraph",
      children: [],
      attributes: clone(context.attributes)
    });
    context.attributes = {};
  };
  const exitPragraph = (context) => {
    const paragraph2 = context.parent;
    if (!isParagraph(paragraph2))
      return;
    if (paragraph2.children.length === 0 || paragraph2.children.every(isWhitespaces)) {
      context.restore();
    } else {
      context.exit("paragraph");
    }
  };
  return {
    name: "paragraph",
    rules: [
      {
        test: "emptyLine",
        action: (_, context) => {
          context.consume();
          exitPragraph(context);
          return "break";
        }
      },
      {
        test: "newline",
        action: (_, { consume }) => consume()
      },
      {
        test: "opening",
        action: (token, context) => {
          if (token.element === "link") {
            const next = context.lexer.peek(1);
            if (next.type === "link.path" && isImage(next.value)) {
              exitPragraph(context);
              return phrasing_default;
            }
          }
          makeSureParagraph(context);
          return phrasing_default;
        }
      },
      {
        test: isPhrasingContent,
        action: (_, context) => {
          makeSureParagraph(context);
          return phrasing_default;
        }
      },
      // catch all
      {
        test: /.*/,
        action: (_, context) => {
          exitPragraph(context);
          return "break";
        }
      }
    ]
  };
};
var paragraph_default = paragraph;

// node_modules/orga/dist/parse/drawer.js
var drawer = (begin, context) => {
  context.save();
  const drawer2 = context.enter({
    type: "drawer",
    name: begin.name,
    value: "",
    children: []
  });
  context.consume();
  const contentStart = begin.position.end;
  return {
    name: "drawer",
    rules: [
      {
        test: ["stars", "EOF"],
        action: (_, context2) => {
          context2.restore();
          context2.lexer.modify((t) => ({
            type: "text",
            value: context2.lexer.substring(t.position),
            position: t.position
          }));
          return "break";
        }
      },
      {
        test: "drawer.end",
        action: (token, context2) => {
          context2.consume();
          drawer2.value = context2.lexer.substring({
            start: contentStart,
            end: token.position.start
          });
          context2.exit("drawer");
          context2.lexer.eat("newline");
          if (drawer2.name.toLowerCase() === "properties") {
            const section2 = context2.parent;
            section2.properties = drawer2.value.split("\n").reduce((accu, current) => {
              const m = current.match(/\s*:(.+?):\s*(.+)\s*$/);
              if (m) {
                return { ...accu, [m[1].toLowerCase()]: m[2] };
              }
              return accu;
            }, section2.properties);
          }
          return "break";
        }
      },
      {
        test: /.*/,
        action: (_, { consume }) => consume()
      }
    ]
  };
};
var drawer_default = drawer;

// node_modules/orga/dist/parse/headline.js
var headline = (token, context) => {
  const { enter } = context;
  const headline2 = enter({
    type: "headline",
    actionable: false,
    children: [],
    level: token.level || context.level
  });
  return {
    name: "headline",
    rules: [
      {
        test: ["newline", "EOF"],
        action: (_, { exit, discard }) => {
          discard();
          exit(headline2.type);
          return "break";
        }
      },
      {
        test: "todo",
        action: (token2) => {
          headline2.keyword = token2.keyword;
          headline2.actionable = token2.actionable;
          return "next";
        }
      },
      {
        test: "tags",
        action: (token2) => {
          headline2.tags = token2.tags;
          return "next";
        }
      },
      {
        test: "priority",
        action: (token2) => {
          headline2.priority = token2.value;
          return "next";
        }
      },
      {
        test: isPhrasingContent,
        action: phrasing_default
      },
      {
        test: /.*/,
        action: (_, { push, lexer }) => {
          push(lexer.eat());
        }
      }
    ]
  };
};
var headline_default = headline;

// node_modules/orga/dist/parse/planning.js
var planning = {
  name: "planning",
  rules: [
    {
      test: "planning.keyword",
      action: (keyword2, context) => {
        const { lexer, enter, push, exit } = context;
        const { eat, eatAll, peek } = lexer;
        const timestamp = peek(1);
        if (!timestamp || timestamp.type !== "planning.timestamp") {
          return "break";
        }
        enter({
          type: "planning",
          keyword: keyword2.value,
          timestamp: timestamp.value,
          children: []
        });
        push(eat());
        push(eat());
        exit("planning");
        if (eatAll("newline") > 1) {
          return "break";
        }
      }
    },
    {
      test: "drawer.begin",
      action: (token, context) => {
        return drawer_default(token, context);
      }
    },
    {
      test: /.*/,
      action: () => {
        return "break";
      }
    }
  ]
};
var planning_default = planning;

// node_modules/orga/dist/parse/section.js
var section = (token, context) => {
  const { enter, exit, exitTo, options: { flat } } = context;
  exit("footnote", false);
  if (!flat) {
    const level = token.level;
    if (level <= context.level) {
      exitTo("section");
      exit("section");
      return;
    }
    enter({
      type: "section",
      level,
      properties: {},
      children: []
    });
  }
  let headlineProcessed = false;
  return {
    name: "section",
    rules: [
      {
        test: "stars",
        action: (token2, context2) => {
          if (headlineProcessed)
            return "break";
          headlineProcessed = true;
          return headline_default(token2, context2);
        }
      },
      {
        test: "planning.keyword",
        action: planning_default
      },
      {
        test: "drawer.begin",
        action: drawer_default
      }
    ]
  };
};
var section_default = section;

// node_modules/orga/dist/parse/table.js
var tableCell = (_, { enter }) => {
  enter({
    type: "table.cell",
    children: []
  });
  return {
    name: "table cell",
    rules: [
      {
        test: ["newline", "table.columnSeparator"],
        action: (_2, { exit }) => {
          exit("table.cell");
          return "break";
        }
      },
      {
        test: isPhrasingContent,
        action: phrasing_default
      },
      {
        test: /.*/,
        action: (_2, { exit }) => {
          exit("table.cell");
          return "break";
        }
      }
    ]
  };
};
var tableRow = (_, { enter, lexer }) => {
  enter({
    type: "table.row",
    children: []
  });
  lexer.eat();
  return {
    name: "table row",
    rules: [
      {
        test: "newline",
        action: (_2, { exit, discard }) => {
          discard();
          exit("table.row");
          return "break";
        }
      },
      { test: "table.columnSeparator", action: (_2, { consume }) => consume() },
      { test: isPhrasingContent, action: tableCell }
    ]
  };
};
var table = (_, context) => {
  context.enter({
    type: "table",
    children: [],
    attributes: {}
  });
  return {
    name: "table",
    rules: [
      { test: "table.columnSeparator", action: tableRow },
      { test: "table.hr", action: (_2, context2) => context2.consume() },
      { test: "newline", action: (_2, context2) => context2.discard() },
      {
        test: /.*/,
        action: (_2, context2) => {
          context2.exitTo("table");
          context2.exit("table");
          return "break";
        }
      }
    ]
  };
};
var table_default = table;

// node_modules/orga/dist/parse/footnote.js
var Footnote = (token, { enter, exitTo, consume }) => {
  exitTo("document");
  enter({
    type: "footnote",
    label: token.label,
    children: []
  });
  consume();
};
var footnote_default = Footnote;

// node_modules/orga/dist/parse/index.js
function test(node, predicate) {
  return toFunc(predicate)(node);
}
function not(test2) {
  return (token) => !toFunc(test2)(token);
}
function toFunc(test2) {
  if (typeof test2 === "function") {
    return (token) => token && test2(token);
  }
  if (test2 === "EOF") {
    return (token) => {
      return token === void 0;
    };
  }
  if (typeof test2 === "string") {
    return (token) => token && test2 === token.type;
  }
  return (token) => token && test2.test(token.type);
}
var main = {
  name: "main",
  rules: [
    {
      test: "emptyLine",
      action: function(_, context) {
        const { consume, exit } = context;
        context.attributes = {};
        exit("footnote", false);
        consume();
      }
    },
    { test: "newline", action: (_, { discard }) => discard() },
    { test: "stars", action: section_default },
    { test: "keyword", action: keyword_default },
    { test: "list.item.bullet", action: list_default },
    { test: "block.begin", action: block_default },
    { test: "latex.begin", action: latex_default },
    { test: /^table\./, action: table_default },
    {
      test: "hr",
      action: (token, { lexer, push }) => {
        lexer.eat();
        push(token);
      }
    },
    { test: isPhrasingContent, action: paragraph_default },
    { test: "footnote.label", action: footnote_default },
    // catch all
    {
      test: /.*/,
      action: (_, { lexer }) => {
        lexer.eat();
      }
    },
    { test: "EOF", action: () => "break" }
  ]
};
function parser(lexer, options) {
  const context = createContext(lexer, options);
  const end = lexer.toOffset(options.range?.end || Infinity);
  const handlerStack = [main];
  function handler() {
    return handlerStack.length > 0 ? handlerStack[handlerStack.length - 1] : void 0;
  }
  let lexerLocation = lexer.save();
  let maxStaleIterations = 10;
  function advance() {
    if (!handler() && lexer.now >= end) {
      return finish();
    }
    if (maxStaleIterations === 0) {
      throw new Error(`it's stuck. 
${context.state}`);
    }
    let nothingMatches = true;
    for (const { test: _test, action } of handler().rules) {
      const token = lexer.peek();
      const predicates = Array.isArray(_test) ? _test : [_test];
      if (!predicates.some((p) => test(token, p)))
        continue;
      nothingMatches = false;
      if (typeof action !== "function") {
        handlerStack.push(action);
        return advance();
      }
      const control = action(token, context);
      if (typeof control === "object") {
        handlerStack.push(control);
        return advance();
      }
      if (control === "break") {
        handlerStack.pop();
        if (lexer.peek() && context.parent.type === "document") {
          return lexer.peek().position.start.offset;
        }
        return advance();
      }
      if (control === "next") {
        continue;
      }
      break;
    }
    if (nothingMatches) {
      handlerStack.pop();
      return advance();
    }
    if (lexer.save() === lexerLocation) {
      maxStaleIterations -= 1;
    } else {
      lexerLocation = lexer.save();
      maxStaleIterations = 10;
    }
    return advance();
  }
  function finish() {
    context.exitTo("document");
    context.exit("document");
    context.tree.position.end = lexer.toPoint(lexer.now);
    return context.tree;
  }
  return {
    advance,
    parse() {
      for (; ; ) {
        const tree = advance();
        if (typeof tree === "number")
          continue;
        return tree;
      }
    },
    finish
  };
}

// node_modules/date-fns-tz/esm/format/index.js
var import_format = __toESM(require_format(), 1);

// node_modules/date-fns-tz/esm/_lib/tzTokenizeDate/index.js
function tzTokenizeDate(date, timeZone) {
  var dtf = getDateTimeFormat(timeZone);
  return dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
}
var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5
};
function partsOffset(dtf, date) {
  try {
    var formatted = dtf.formatToParts(date);
    var filled = [];
    for (var i = 0; i < formatted.length; i++) {
      var pos = typeToPos[formatted[i].type];
      if (pos >= 0) {
        filled[pos] = parseInt(formatted[i].value, 10);
      }
    }
    return filled;
  } catch (error) {
    if (error instanceof RangeError) {
      return [NaN];
    }
    throw error;
  }
}
function hackyOffset(dtf, date) {
  var formatted = dtf.format(date);
  var parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted);
  return [parsed[3], parsed[1], parsed[2], parsed[4], parsed[5], parsed[6]];
}
var dtfCache = {};
function getDateTimeFormat(timeZone) {
  if (!dtfCache[timeZone]) {
    var testDateFormatted = new Intl.DateTimeFormat("en-US", {
      hourCycle: "h23",
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }).format(/* @__PURE__ */ new Date("2014-06-25T04:00:00.123Z"));
    var hourCycleSupported = testDateFormatted === "06/25/2014, 00:00:00" || testDateFormatted === "‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00";
    dtfCache[timeZone] = hourCycleSupported ? new Intl.DateTimeFormat("en-US", {
      hourCycle: "h23",
      timeZone,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }) : new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }
  return dtfCache[timeZone];
}

// node_modules/date-fns-tz/esm/_lib/newDateUTC/index.js
function newDateUTC(fullYear, month, day, hour, minute, second, millisecond) {
  var utcDate = /* @__PURE__ */ new Date(0);
  utcDate.setUTCFullYear(fullYear, month, day);
  utcDate.setUTCHours(hour, minute, second, millisecond);
  return utcDate;
}

// node_modules/date-fns-tz/esm/_lib/tzParseTimezone/index.js
var MILLISECONDS_IN_HOUR = 36e5;
var MILLISECONDS_IN_MINUTE = 6e4;
var patterns = {
  timezone: /([Z+-].*)$/,
  timezoneZ: /^(Z)$/,
  timezoneHH: /^([+-]\d{2})$/,
  timezoneHHMM: /^([+-])(\d{2}):?(\d{2})$/
};
function tzParseTimezone(timezoneString, date, isUtcDate) {
  var token;
  var absoluteOffset;
  if (!timezoneString) {
    return 0;
  }
  token = patterns.timezoneZ.exec(timezoneString);
  if (token) {
    return 0;
  }
  var hours;
  token = patterns.timezoneHH.exec(timezoneString);
  if (token) {
    hours = parseInt(token[1], 10);
    if (!validateTimezone(hours)) {
      return NaN;
    }
    return -(hours * MILLISECONDS_IN_HOUR);
  }
  token = patterns.timezoneHHMM.exec(timezoneString);
  if (token) {
    hours = parseInt(token[2], 10);
    var minutes = parseInt(token[3], 10);
    if (!validateTimezone(hours, minutes)) {
      return NaN;
    }
    absoluteOffset = Math.abs(hours) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;
    return token[1] === "+" ? -absoluteOffset : absoluteOffset;
  }
  if (isValidTimezoneIANAString(timezoneString)) {
    date = new Date(date || Date.now());
    var utcDate = isUtcDate ? date : toUtcDate(date);
    var offset = calcOffset(utcDate, timezoneString);
    var fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString);
    return -fixedOffset;
  }
  return NaN;
}
function toUtcDate(date) {
  return newDateUTC(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    date.getHours(),
    date.getMinutes(),
    date.getSeconds(),
    date.getMilliseconds()
  );
}
function calcOffset(date, timezoneString) {
  var tokens = tzTokenizeDate(date, timezoneString);
  var asUTC = newDateUTC(
    tokens[0],
    tokens[1] - 1,
    tokens[2],
    tokens[3] % 24,
    tokens[4],
    tokens[5],
    0
  ).getTime();
  var asTS = date.getTime();
  var over = asTS % 1e3;
  asTS -= over >= 0 ? over : 1e3 + over;
  return asUTC - asTS;
}
function fixOffset(date, offset, timezoneString) {
  var localTS = date.getTime();
  var utcGuess = localTS - offset;
  var o2 = calcOffset(new Date(utcGuess), timezoneString);
  if (offset === o2) {
    return offset;
  }
  utcGuess -= o2 - offset;
  var o3 = calcOffset(new Date(utcGuess), timezoneString);
  if (o2 === o3) {
    return o2;
  }
  return Math.max(o2, o3);
}
function validateTimezone(hours, minutes) {
  return -23 <= hours && hours <= 23 && (minutes == null || 0 <= minutes && minutes <= 59);
}
var validIANATimezoneCache = {};
function isValidTimezoneIANAString(timeZoneString) {
  if (validIANATimezoneCache[timeZoneString]) return true;
  try {
    new Intl.DateTimeFormat(void 0, { timeZone: timeZoneString });
    validIANATimezoneCache[timeZoneString] = true;
    return true;
  } catch (error) {
    return false;
  }
}

// node_modules/date-fns-tz/esm/format/formatters/index.js
var MILLISECONDS_IN_MINUTE2 = 60 * 1e3;

// node_modules/date-fns-tz/esm/toDate/index.js
var import_toInteger = __toESM(require_toInteger(), 1);
var import_getTimezoneOffsetInMilliseconds = __toESM(require_getTimezoneOffsetInMilliseconds(), 1);

// node_modules/date-fns-tz/esm/_lib/tzPattern/index.js
var tzPattern = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/;
var tzPattern_default = tzPattern;

// node_modules/date-fns-tz/esm/toDate/index.js
var MILLISECONDS_IN_HOUR2 = 36e5;
var MILLISECONDS_IN_MINUTE3 = 6e4;
var DEFAULT_ADDITIONAL_DIGITS = 2;
var patterns2 = {
  dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
  datePattern: /^([0-9W+-]+)(.*)/,
  plainTime: /:/,
  // year tokens
  YY: /^(\d{2})$/,
  YYY: [
    /^([+-]\d{2})$/,
    // 0 additional digits
    /^([+-]\d{3})$/,
    // 1 additional digit
    /^([+-]\d{4})$/
    // 2 additional digits
  ],
  YYYY: /^(\d{4})/,
  YYYYY: [
    /^([+-]\d{4})/,
    // 0 additional digits
    /^([+-]\d{5})/,
    // 1 additional digit
    /^([+-]\d{6})/
    // 2 additional digits
  ],
  // date tokens
  MM: /^-(\d{2})$/,
  DDD: /^-?(\d{3})$/,
  MMDD: /^-?(\d{2})-?(\d{2})$/,
  Www: /^-?W(\d{2})$/,
  WwwD: /^-?W(\d{2})-?(\d{1})$/,
  HH: /^(\d{2}([.,]\d*)?)$/,
  HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
  HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
  // time zone tokens (to identify the presence of a tz)
  timeZone: tzPattern_default
};
function toDate(argument, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  if (argument === null) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var options = dirtyOptions || {};
  var additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : (0, import_toInteger.default)(options.additionalDigits);
  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  }
  if (argument instanceof Date || typeof argument === "object" && Object.prototype.toString.call(argument) === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || Object.prototype.toString.call(argument) === "[object Number]") {
    return new Date(argument);
  } else if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var dateStrings = splitDateString(argument);
  var parseYearResult = parseYear(dateStrings.date, additionalDigits);
  var year = parseYearResult.year;
  var restDateString = parseYearResult.restDateString;
  var date = parseDate(restDateString, year);
  if (isNaN(date)) {
    return /* @__PURE__ */ new Date(NaN);
  }
  if (date) {
    var timestamp = date.getTime();
    var time = 0;
    var offset;
    if (dateStrings.time) {
      time = parseTime(dateStrings.time);
      if (isNaN(time)) {
        return /* @__PURE__ */ new Date(NaN);
      }
    }
    if (dateStrings.timeZone || options.timeZone) {
      offset = tzParseTimezone(dateStrings.timeZone || options.timeZone, new Date(timestamp + time));
      if (isNaN(offset)) {
        return /* @__PURE__ */ new Date(NaN);
      }
    } else {
      offset = (0, import_getTimezoneOffsetInMilliseconds.default)(new Date(timestamp + time));
      offset = (0, import_getTimezoneOffsetInMilliseconds.default)(new Date(timestamp + time + offset));
    }
    return new Date(timestamp + time + offset);
  } else {
    return /* @__PURE__ */ new Date(NaN);
  }
}
function splitDateString(dateString) {
  var dateStrings = {};
  var parts = patterns2.dateTimePattern.exec(dateString);
  var timeString;
  if (!parts) {
    parts = patterns2.datePattern.exec(dateString);
    if (parts) {
      dateStrings.date = parts[1];
      timeString = parts[2];
    } else {
      dateStrings.date = null;
      timeString = dateString;
    }
  } else {
    dateStrings.date = parts[1];
    timeString = parts[3];
  }
  if (timeString) {
    var token = patterns2.timeZone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], "");
      dateStrings.timeZone = token[1].trim();
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  var patternYYY = patterns2.YYY[additionalDigits];
  var patternYYYYY = patterns2.YYYYY[additionalDigits];
  var token;
  token = patterns2.YYYY.exec(dateString) || patternYYYYY.exec(dateString);
  if (token) {
    var yearString = token[1];
    return {
      year: parseInt(yearString, 10),
      restDateString: dateString.slice(yearString.length)
    };
  }
  token = patterns2.YY.exec(dateString) || patternYYY.exec(dateString);
  if (token) {
    var centuryString = token[1];
    return {
      year: parseInt(centuryString, 10) * 100,
      restDateString: dateString.slice(centuryString.length)
    };
  }
  return {
    year: null
  };
}
function parseDate(dateString, year) {
  if (year === null) {
    return null;
  }
  var token;
  var date;
  var month;
  var week;
  if (dateString.length === 0) {
    date = /* @__PURE__ */ new Date(0);
    date.setUTCFullYear(year);
    return date;
  }
  token = patterns2.MM.exec(dateString);
  if (token) {
    date = /* @__PURE__ */ new Date(0);
    month = parseInt(token[1], 10) - 1;
    if (!validateDate(year, month)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date.setUTCFullYear(year, month);
    return date;
  }
  token = patterns2.DDD.exec(dateString);
  if (token) {
    date = /* @__PURE__ */ new Date(0);
    var dayOfYear = parseInt(token[1], 10);
    if (!validateDayOfYearDate(year, dayOfYear)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date.setUTCFullYear(year, 0, dayOfYear);
    return date;
  }
  token = patterns2.MMDD.exec(dateString);
  if (token) {
    date = /* @__PURE__ */ new Date(0);
    month = parseInt(token[1], 10) - 1;
    var day = parseInt(token[2], 10);
    if (!validateDate(year, month, day)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date.setUTCFullYear(year, month, day);
    return date;
  }
  token = patterns2.Www.exec(dateString);
  if (token) {
    week = parseInt(token[1], 10) - 1;
    if (!validateWeekDate(year, week)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return dayOfISOWeekYear(year, week);
  }
  token = patterns2.WwwD.exec(dateString);
  if (token) {
    week = parseInt(token[1], 10) - 1;
    var dayOfWeek = parseInt(token[2], 10) - 1;
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  }
  return null;
}
function parseTime(timeString) {
  var token;
  var hours;
  var minutes;
  token = patterns2.HH.exec(timeString);
  if (token) {
    hours = parseFloat(token[1].replace(",", "."));
    if (!validateTime(hours)) {
      return NaN;
    }
    return hours % 24 * MILLISECONDS_IN_HOUR2;
  }
  token = patterns2.HHMM.exec(timeString);
  if (token) {
    hours = parseInt(token[1], 10);
    minutes = parseFloat(token[2].replace(",", "."));
    if (!validateTime(hours, minutes)) {
      return NaN;
    }
    return hours % 24 * MILLISECONDS_IN_HOUR2 + minutes * MILLISECONDS_IN_MINUTE3;
  }
  token = patterns2.HHMMSS.exec(timeString);
  if (token) {
    hours = parseInt(token[1], 10);
    minutes = parseInt(token[2], 10);
    var seconds = parseFloat(token[3].replace(",", "."));
    if (!validateTime(hours, minutes, seconds)) {
      return NaN;
    }
    return hours % 24 * MILLISECONDS_IN_HOUR2 + minutes * MILLISECONDS_IN_MINUTE3 + seconds * 1e3;
  }
  return null;
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  week = week || 0;
  day = day || 0;
  var date = /* @__PURE__ */ new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7;
  var diff = week * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date) {
  if (month < 0 || month > 11) {
    return false;
  }
  if (date != null) {
    if (date < 1) {
      return false;
    }
    var isLeapYear = isLeapYearIndex(year);
    if (isLeapYear && date > DAYS_IN_MONTH_LEAP_YEAR[month]) {
      return false;
    }
    if (!isLeapYear && date > DAYS_IN_MONTH[month]) {
      return false;
    }
  }
  return true;
}
function validateDayOfYearDate(year, dayOfYear) {
  if (dayOfYear < 1) {
    return false;
  }
  var isLeapYear = isLeapYearIndex(year);
  if (isLeapYear && dayOfYear > 366) {
    return false;
  }
  if (!isLeapYear && dayOfYear > 365) {
    return false;
  }
  return true;
}
function validateWeekDate(year, week, day) {
  if (week < 0 || week > 52) {
    return false;
  }
  if (day != null && (day < 0 || day > 6)) {
    return false;
  }
  return true;
}
function validateTime(hours, minutes, seconds) {
  if (hours != null && (hours < 0 || hours >= 25)) {
    return false;
  }
  if (minutes != null && (minutes < 0 || minutes >= 60)) {
    return false;
  }
  if (seconds != null && (seconds < 0 || seconds >= 60)) {
    return false;
  }
  return true;
}

// node_modules/date-fns-tz/esm/formatInTimeZone/index.js
var import_cloneObject = __toESM(require_cloneObject(), 1);

// node_modules/date-fns-tz/esm/zonedTimeToUtc/index.js
var import_cloneObject2 = __toESM(require_cloneObject(), 1);
function zonedTimeToUtc(date, timeZone, options) {
  if (typeof date === "string" && !date.match(tzPattern_default)) {
    var extendedOptions = (0, import_cloneObject2.default)(options);
    extendedOptions.timeZone = timeZone;
    return toDate(date, extendedOptions);
  }
  var d = toDate(date, options);
  var utc = newDateUTC(
    d.getFullYear(),
    d.getMonth(),
    d.getDate(),
    d.getHours(),
    d.getMinutes(),
    d.getSeconds(),
    d.getMilliseconds()
  ).getTime();
  var offsetMilliseconds = tzParseTimezone(timeZone, new Date(utc));
  return new Date(utc + offsetMilliseconds);
}

// node_modules/text-kit/lib/core.js
function clamp(num, min, max) {
  return num > max ? max : num < min ? min : num;
}
function core(text) {
  const strLines = text.split(/^/gm);
  const lines = strLines.length > 0 ? [0] : [];
  strLines.slice(0, strLines.length - 1).forEach((l, i) => lines.push(lines[i] + l.length));
  function eof() {
    if (lines.length === 0) {
      return { line: 1, column: 1, offset: 0 };
    }
    return {
      line: lines.length,
      column: text.length - lines[lines.length - 1] + 1,
      offset: text.length
    };
  }
  function bol(ln) {
    const lineIndex = ln - 1;
    if (lineIndex >= lines.length || lineIndex < 0) return null;
    return { line: ln, column: 1, offset: lines[ln - 1] };
  }
  function eol(ln) {
    if (ln > lines.length || ln < 1) return null;
    const lastLine = ln === lines.length;
    return lastLine ? eof() : toPoint(lines[ln] - 1);
  }
  function shift(point2, offset) {
    return toPoint(toIndex(point2) + offset);
  }
  function toPoint(index) {
    if (index <= 0) return { line: 1, column: 1, offset: 0 };
    if (index >= text.length) return eof();
    let lineIndex = lines.findIndex((l) => l > index);
    if (lineIndex < 0) {
      lineIndex = lines.length;
    }
    return {
      line: lineIndex,
      column: index - lines[lineIndex - 1] + 1,
      offset: index
    };
  }
  function toIndex(point2) {
    if (typeof point2 === "number") return clamp(point2, 0, text.length);
    if (point2.offset) return clamp(point2.offset, 0, text.length);
    const lineIndex = point2.line - 1;
    if (lineIndex < 0 || lines.length === 0) return 0;
    if (lineIndex >= lines.length) return text.length;
    const i = lines[lineIndex] + point2.column - 1;
    return Math.min(i, text.length);
  }
  return {
    get text() {
      return text;
    },
    get numberOfLines() {
      return lines.length;
    },
    shift,
    toPoint,
    toIndex,
    bol,
    eol
  };
}
var core_default = core;

// node_modules/text-kit/lib/utils/substring.js
function addSubstring(core2) {
  function substring(start, end) {
    const { toIndex } = core2;
    return core2.text.substring(toIndex(start), end && toIndex(end));
  }
  return {
    ...core2,
    substring
  };
}

// node_modules/text-kit/lib/utils/lines.js
function lines_default(core2) {
  function linePosition(start, end) {
    let result = null;
    if (typeof start === "number") {
      result = linePosition(core2.toPoint(start));
    } else {
      const s = core2.bol(start.line);
      const e = core2.eol(start.line);
      if (!s || !e) return null;
      result = {
        start: s,
        end: e
      };
    }
    if (end && result) {
      const endLR = linePosition(end);
      if (!endLR) return null;
      result.end = endLR.end;
    }
    return result;
  }
  function endOfLine(ln) {
    const pos = linePosition(ln);
    if (!pos) return void 0;
    return pos.end;
  }
  const beginOfLine = (ln) => {
    const pos = linePosition(ln);
    if (!pos) return void 0;
    return pos.start;
  };
  return {
    ...core2,
    linePosition,
    endOfLine,
    beginOfLine
  };
}

// node_modules/text-kit/lib/utils/index.js
function enhance(core2) {
  return addSubstring(lines_default(core2));
}

// node_modules/text-kit/lib/reader.js
var PAIRS = [
  ["{", "}"],
  ["[", "]"],
  ["(", ")"],
  ["<", ">"]
].reduce((all, [l, r]) => {
  return {
    ...all,
    [l]: r,
    [r]: l
  };
}, {});
function reader(_core, range = {}) {
  const core2 = enhance(_core);
  let cursor = core2.toIndex(range.start || 0);
  const end = core2.toIndex(range.end || Infinity);
  const getChar = (offset = 0) => {
    const index = cursor + offset;
    if (index >= end || index < 0) return void 0;
    return core2.text.charAt(index);
  };
  function getLine() {
    const pos = core2.linePosition(cursor);
    if (!pos) return null;
    return core2.substring(cursor, pos.end);
  }
  function jump(point2) {
    cursor = Math.min(end, core2.toIndex(point2));
  }
  const now = () => core2.toPoint(cursor);
  function eat(param = "char") {
    let value;
    const position = {
      start: core2.toPoint(cursor),
      end: core2.toPoint(cursor)
    };
    if (cursor >= end) return void 0;
    if (param === "char") {
      value = getChar();
      cursor += 1;
    } else if (param === "line") {
      const lineEnd = core2.linePosition(cursor);
      const e = lineEnd === null ? end : Math.min(end, lineEnd.end.offset ?? end);
      value = core2.substring(cursor, e);
      cursor = e;
    } else if (param === "whitespaces") {
      return eat(/^[ \t]+/);
    } else if (param === "newline") {
      return eat(/^[\n\r]/);
    } else if (typeof param === "number") {
      const adv = Math.min(param, end - cursor);
      value = core2.text.substring(cursor, cursor + adv);
      cursor += adv;
    } else {
      const m = match(param);
      if (!m) return;
      if (m.position.end.offset !== void 0) cursor = m.position.end.offset;
      value = m.result[0];
    }
    position.end = core2.toPoint(cursor);
    return {
      position,
      value: value || ""
    };
  }
  function match(pattern, range2 = {}) {
    const s = range2.start?.offset || cursor;
    const e = range2.end?.offset || end;
    const str = core2.text.substring(s, e);
    const m = pattern.exec(str);
    if (!m) return;
    return {
      result: m,
      position: {
        start: core2.toPoint(cursor + m.index),
        end: core2.toPoint(cursor + m.index + m[0].length)
      }
    };
  }
  function findClosing(index = cursor) {
    let cursor2 = core2.toIndex(index);
    const opening = core2.text.charAt(cursor2);
    if (!opening) return;
    const closing = PAIRS[opening] || opening;
    let balance = 1;
    cursor2 += 1;
    while (cursor2 < end) {
      const char = core2.text.charAt(cursor2);
      if (char === opening) {
        balance += 1;
      }
      if (char === closing) {
        if (opening !== closing) {
          balance -= 1;
        } else {
          balance = 0;
        }
      }
      if (balance === 0) {
        return core2.toPoint(cursor2);
      }
      cursor2 += 1;
    }
  }
  const isStartOfLine = () => {
    return cursor === 0 || getChar(-1) === "\n";
  };
  function indexOf(str, range2 = {}) {
    const s = range2.start?.offset || cursor;
    const e = range2.end?.offset || core2.endOfLine(cursor)?.offset || end;
    const substr = core2.text.substring(s, e);
    const i = substr.indexOf(str);
    if (i === -1) return null;
    return core2.toPoint(cursor + i);
  }
  return {
    ...core2,
    getChar,
    getLine,
    eat,
    jump,
    match,
    indexOf,
    findClosing,
    isStartOfLine,
    now: () => {
      return now();
    },
    beginOfLine: () => core2.beginOfLine(cursor),
    endOfLine: () => core2.endOfLine(cursor),
    /**
     * Read a range of text
     * @param {Partial<Range>} [range={}]
     */
    read: (range2 = {}) => {
      return reader(_core, {
        start: range2.start || cursor,
        end: range2.end || end
      });
    }
  };
}
var reader_default = reader;

// node_modules/text-kit/index.js
function read(text, range = {}) {
  return reader_default(core_default(text), range);
}

// node_modules/orga/dist/timestamp.js
var parse = (input, { timezone = Intl.DateTimeFormat().resolvedOptions().timeZone } = {}) => {
  const { match, eat, getChar, jump } = read(input);
  eat("whitespaces");
  const timestamp = () => {
    const opening = eat(/[<[]/g);
    if (!opening)
      return;
    const active = opening.value === "<";
    const { value: _date } = eat(/\d{4}-\d{2}-\d{2}/);
    let date = _date;
    eat("whitespaces");
    let end;
    const { value: _day } = eat(/[a-zA-Z]+/);
    eat("whitespaces");
    const time = match(/(\d{2}:\d{2})(?:-(\d{2}:\d{2}))?/);
    if (time) {
      date = `${_date} ${time.result[1]}`;
      if (time.result[2]) {
        end = `${_date} ${time.result[2]}`;
      }
      jump(time.position.end);
    }
    const closing = getChar();
    if (opening.value === "[" && closing === "]" || opening.value === "<" && closing === ">") {
      eat("char");
      return {
        date: zonedTimeToUtc(date, timezone),
        end: end ? zonedTimeToUtc(end, timezone) : void 0
      };
    }
  };
  const ts = timestamp();
  if (!ts)
    return;
  if (!ts.end) {
    const doubleDash = eat(/--/);
    if (doubleDash) {
      const end = timestamp();
      if (end) {
        ts.end = end.date;
      }
    }
  }
  return ts;
};

// node_modules/orga/dist/todo-keyword-set.js
var todo_keyword_set_default = (text) => {
  const actionables = text.split(" ").map((p) => p.trim()).filter(String);
  const pipe = actionables.indexOf("|");
  const done = actionables.splice(pipe).filter((t) => t !== "|");
  return {
    actionables,
    done,
    get keywords() {
      return actionables.concat(done);
    }
  };
};

// node_modules/orga/dist/tokenize/block.js
var block_default2 = (reader2) => {
  const { match, eat, endOfLine, jump } = reader2;
  const ws = eat("whitespaces");
  const b = match(/#\+begin_([^\s\n]+)\s*(.*)$/imy, { end: endOfLine() });
  if (b) {
    eat("line");
    const params = b.result[2].split(" ").map((p) => p.trim()).filter(String);
    return [
      {
        type: "block.begin",
        name: b.result[1],
        params,
        position: { ...b.position }
      }
    ];
  }
  const e = match(/#\+end_([^\s\n]+)\s*$/imy, { end: endOfLine() });
  if (e) {
    reader2.eat("line");
    return [
      {
        type: "block.end",
        name: e.result[1],
        position: { ...e.position }
      }
    ];
  }
  ws && jump(ws.position.start);
};

// node_modules/orga/dist/tokenize/latex.js
var latex_default2 = (reader2) => {
  const { match, eat, endOfLine } = reader2;
  const b = match(/\\begin\{([a-zA-Z0-9*]+)\}\s*$/imy, { end: endOfLine() });
  if (b) {
    eat("line");
    return [
      {
        type: "latex.begin",
        name: b.result[1],
        position: { ...b.position }
      }
    ];
  }
  const e = match(/\\end\{([a-zA-Z0-9*]+)\}\s*$/imy, { end: endOfLine() });
  if (e) {
    reader2.eat("line");
    return [
      {
        type: "latex.end",
        name: e.result[1],
        position: { ...e.position }
      }
    ];
  }
};

// node_modules/orga/dist/tokenize/comment.js
var comment_default = ({ match, eat, jump }) => {
  const ws = eat("whitespaces");
  if (match(/^#\s/y)) {
    const comment = match(/^#\s+(.*)$/my);
    if (comment) {
      eat("line");
      return {
        type: "comment",
        position: comment.position,
        value: comment.result[1]
      };
    }
  }
  ws && jump(ws.position.start);
};

// node_modules/orga/dist/tokenize/drawer.js
var drawer_default2 = (reader2) => {
  const { match, jump, eat } = reader2;
  const ws = eat("whitespaces");
  const drawerReg = /:(\w+):(?=[ \t]*$)/my;
  const m = match(drawerReg);
  if (m) {
    jump(m.position.end);
    const name = m.result[1];
    eat("whitespaces");
    if (name.toLowerCase() === "end") {
      return [
        {
          type: "drawer.end",
          position: m.position
        }
      ];
    } else {
      return [
        {
          type: "drawer.begin",
          name,
          position: m.position
        }
      ];
    }
  }
  ws && jump(ws.position.start);
  return [];
};

// node_modules/orga/dist/uri.js
var URL_PATTERN = /(?:([a-z][a-z0-9+.-]*):)?(.*)/i;
var isFilePath = (str) => {
  return str && /^\.{0,2}\//.test(str);
};
var uri_default = (link) => {
  const m = URL_PATTERN.exec(link);
  if (!m)
    return void 0;
  const protocol = (m[1] || (isFilePath(m[2]) ? `file` : `internal`)).toLowerCase();
  let value = m[2];
  if (/https?/.test(protocol)) {
    value = `${protocol}:${value}`;
  }
  let search;
  if (protocol === "file") {
    const m2 = /(.*?)::(.*)/.exec(value);
    if (m2 && m2[1] && m2[2]) {
      value = m2[1];
      search = parseInt(m2[2]);
      search = Number.isInteger(search) ? search : m2[2];
    }
  }
  return { protocol, value, search };
};

// node_modules/orga/dist/tokenize/inline/text.js
var MARKERS = {
  "*": "bold",
  "=": "verbatim",
  "/": "italic",
  "+": "strikeThrough",
  _: "underline",
  "~": "code"
};
var tokenizeText = (bol = void 0) => (reader2) => {
  const tokens = [];
  const { now, eat, jump, getChar, findClosing, substring } = reader2;
  const marker = getChar();
  const style = MARKERS[marker];
  if (!style)
    return;
  const pre = getChar(-1);
  const isBOL = bol && bol.offset === now().offset || now().column === 1;
  if (!isBOL && !/[\s({'"]/.test(pre))
    return;
  const tokenStart = now();
  const closing = findClosing(now());
  if (!closing)
    return;
  eat();
  const valueStart = now();
  if (getChar().match(/\s/))
    return;
  jump(closing);
  if (getChar(-1).match(/\s/))
    return;
  const post = getChar(1);
  if (post && ` 	
-.,;:!?')}["`.indexOf(post) === -1)
    return;
  const valueEnd = now();
  eat();
  tokens.push({
    type: "text",
    style,
    value: substring(valueStart, valueEnd),
    position: { start: tokenStart, end: now() }
  });
  return tokens;
};
var text_default = tokenizeText;

// node_modules/orga/dist/tokenize/inline/link.js
var tokenizeLink = (reader2) => {
  const tokens = [];
  const { eat, findClosing, jump, getChar, now } = reader2;
  if (getChar() !== "[") {
    return;
  }
  const linkOpening = eat("char");
  tokens.push({
    type: "opening",
    element: "link",
    position: linkOpening.position
  });
  const linkClosing = findClosing(linkOpening.position.start);
  if (!linkClosing)
    return;
  if (getChar() !== "[") {
    return;
  }
  const pathOpening = eat("char");
  const pathClosing = findClosing(pathOpening.position.start);
  if (!pathClosing)
    return;
  const linkInfo = uri_default(reader2.substring(pathOpening.position.end, pathClosing));
  if (!linkInfo)
    return;
  jump(pathClosing);
  eat("char");
  tokens.push({
    type: "link.path",
    ...linkInfo,
    position: {
      start: pathOpening.position.start,
      end: now()
    }
  });
  if (getChar() === "[") {
    const descClosing = findClosing();
    if (!descClosing) {
      return;
    }
    eat();
    const desc = tokenize(reader2.read({ end: descClosing }), [
      text_default(now())
    ]);
    tokens.push(...desc);
  }
  jump(linkClosing);
  tokens.push({
    type: "closing",
    element: "link",
    position: eat().position
  });
  return tokens;
};
var link_default = tokenizeLink;

// node_modules/orga/dist/tokenize/inline/math.js
var tokenizeMath = (reader2) => {
  const { now, eat, getChar, jump, substring, match } = reader2;
  const tokens = [];
  const tokenStart = now();
  let closingMatch;
  if (getChar() === "\\") {
    eat();
    const opening = getChar();
    if (opening === "(") {
      closingMatch = /\\\)/;
    } else if (opening === "[") {
      closingMatch = /\\]/;
    } else
      return;
    eat();
  } else if (getChar() === "$") {
    eat();
    if (getChar() === "$") {
      eat();
      closingMatch = /\$\$/;
    } else
      return;
  }
  if (!closingMatch)
    return;
  const valueStart = now();
  const m = match(closingMatch);
  if (!m)
    return;
  const valueEnd = m.position.start;
  jump(m.position.end);
  const tokenEnd = now();
  tokens.push({
    type: "text",
    style: "math",
    value: substring(valueStart, valueEnd),
    position: { start: tokenStart, end: tokenEnd }
  });
  return tokens;
};
var math_default = tokenizeMath;

// node_modules/orga/dist/tokenize/inline/footnote.js
var tokFootnoteRefernece = (reader2) => {
  const tokens = [];
  const { eat, now, jump } = reader2;
  const fnb = eat(/^\[fn:/);
  if (!fnb)
    return;
  tokens.push({
    type: "opening",
    element: "footnote.reference",
    position: fnb.position
  });
  const closing = reader2.findClosing(fnb.position.start);
  if (!closing)
    return;
  const label = eat(/^[\w_-]+/);
  if (label) {
    tokens.push({
      type: "footnote.label",
      label: label.value,
      position: label.position
    });
  }
  if (label && now().offset === closing.offset) {
    tokens.push({
      type: "closing",
      element: "footnote.reference",
      position: eat().position
    });
    return tokens;
  }
  if (!eat(/^:/))
    return;
  const defRange = {
    start: now(),
    end: closing
  };
  const more = tokenize(reader2.read(defRange));
  tokens.push(...more);
  jump(closing);
  tokens.push({
    type: "closing",
    element: "footnote.reference",
    position: eat().position
  });
  return tokens;
};
var footnote_default2 = tokFootnoteRefernece;

// node_modules/orga/dist/tokenize/inline/index.js
var ALL = [
  footnote_default2,
  link_default,
  math_default,
  text_default()
];
var tokenize = (reader2, tokenizers = ALL, { ignoring } = { ignoring: [] }) => {
  const { now, eat, jump, substring, getChar, toPoint } = reader2;
  const _tokens = [];
  let cursor = now().offset;
  const push = (...tokens) => {
    if (tokens.length === 0)
      return;
    const textEnd = tokens[0].position.start;
    if (cursor < textEnd.offset) {
      _tokens.push({
        type: "text",
        value: substring(cursor, textEnd),
        position: { start: toPoint(cursor), end: { ...textEnd } }
      });
    }
    cursor = tokens[tokens.length - 1].position.end.offset;
    _tokens.push(...tokens);
  };
  main: while (getChar()) {
    const newline = eat("newline");
    if (newline) {
      push({
        type: "newline",
        position: newline.position
      });
      break;
    }
    for (const t of tokenizers) {
      const r = reader2.read();
      const tokens = t(r);
      if (tokens) {
        push(...Array.isArray(tokens) ? tokens : [tokens]);
        jump(r.now());
        continue main;
      }
    }
    eat();
  }
  if (cursor < now().offset) {
    const value = substring(cursor, reader2.now());
    _tokens.push({
      type: "text",
      value,
      position: { start: toPoint(cursor), end: reader2.now() }
    });
  }
  return _tokens;
};

// node_modules/orga/dist/tokenize/footnote.js
var footnote_default3 = (reader2) => {
  const { isStartOfLine, match, jump, eat } = reader2;
  if (!isStartOfLine())
    return;
  let tokens = [];
  const m = match(/^\[fn:([^\]]+)\](?=\s)/y);
  if (!m)
    return [];
  tokens.push({
    type: "footnote.label",
    label: m.result[1],
    position: m.position
  });
  jump(m.position.end);
  eat("whitespaces");
  tokens = tokens.concat(tokenize(reader2));
  return tokens;
};

// node_modules/orga/dist/tokenize/headline.js
var headline_default2 = (getTodoKeywordSets) => (reader2) => {
  const { isStartOfLine, match, now, eol, eat, jump, substring, endOfLine } = reader2;
  const todoKeywordSets = getTodoKeywordSets();
  if (!isStartOfLine() || !match(/^\*+[ \t]+/my))
    return;
  const todos = todoKeywordSets.flatMap((s) => s.keywords);
  const isActionable = (keyword3) => {
    return !!todoKeywordSets.find((s) => s.actionables.includes(keyword3));
  };
  let buffer = [];
  const stars = eat(/^\*+(?=\s)/);
  if (!stars)
    throw Error("not gonna happen");
  buffer.push({
    type: "stars",
    level: stars.value.length,
    position: {
      start: stars.position.start,
      end: eat("whitespaces").position.end
    }
  });
  const keyword2 = eat(RegExp(`${todos.map(escape).join("|")}(?=\\s)`, "y"));
  if (keyword2) {
    buffer.push({
      type: "todo",
      keyword: keyword2.value,
      actionable: isActionable(keyword2.value),
      position: {
        start: keyword2.position.start,
        end: eat("whitespaces").position.end
      }
    });
  }
  const priority = eat(/^\[#(A|B|C)\](?=\s)/y);
  if (priority) {
    buffer.push({
      type: "priority",
      ...priority,
      position: {
        start: priority.position.start,
        end: eat("whitespaces").position.end
      }
    });
  }
  const tags = match(/[ \t]+(:(?:[\w@_#%-]+:)+)[ \t]*$/m, {
    end: endOfLine()
  });
  let contentEnd = eol(now().line);
  if (tags) {
    contentEnd = tags.position.start;
  }
  const r = reader2.read({ end: contentEnd });
  const tokens = tokenize(r);
  jump(r.now());
  buffer = buffer.concat(tokens);
  if (tags) {
    eat("whitespaces");
    const tagsPosition = { start: now(), end: tags.position.end };
    const s = substring(tagsPosition.start, tagsPosition.end);
    buffer.push({
      type: "tags",
      tags: s.split(":").map((t) => t.trim()).filter(Boolean),
      position: { start: now(), end: tags.position.end }
    });
    jump(tags.position.end);
  }
  return buffer;
};

// node_modules/orga/dist/tokenize/hr.js
var hr_default = ({ eat }) => {
  const hr = eat(/^\s*-{5,}\s*$/my);
  if (hr) {
    return {
      type: "hr",
      position: hr.position
    };
  }
};

// node_modules/orga/dist/tokenize/keyword.js
var keyword_default2 = (reader2) => {
  const keyword2 = reader2.match(/#\+(\w+):\s*([^\n]*)$/my);
  if (keyword2) {
    reader2.eat("line");
    const tokens = [
      {
        type: "keyword",
        key: keyword2.result[1],
        value: keyword2.result[2],
        position: keyword2.position
      }
    ];
    const nl = reader2.eat("newline");
    if (nl) {
      tokens.push({
        type: "newline",
        position: nl.position
      });
    }
    return tokens;
  }
};

// node_modules/orga/dist/tokenize/list.js
var list_default2 = (reader2) => {
  const { now, match, eat, jump, substring, endOfLine } = reader2;
  const ws = eat("whitespaces");
  let tokens = [];
  const indent = now().column - 1;
  const bullet = match(/^([-+]|\d+[.)])(?=\s)/y);
  if (!bullet) {
    ws && jump(ws.position.start);
    return [];
  }
  tokens.push({
    type: "list.item.bullet",
    indent,
    ordered: /^\d/.test(bullet.result[1]),
    position: bullet.position
  });
  jump(bullet.position.end);
  eat("whitespaces");
  const checkbox = match(/^\[(x|X|-| )\](?=\s)/y);
  if (checkbox) {
    tokens.push({
      type: "list.item.checkbox",
      checked: checkbox.result[1] !== " ",
      position: checkbox.position
    });
    jump(checkbox.position.end);
  }
  eat("whitespaces");
  const tagMark = match(/\s+::\s+/, { end: endOfLine() });
  if (tagMark) {
    const pos = { start: now(), end: tagMark.position.start };
    tokens.push({
      type: "list.item.tag",
      value: substring(pos.start, pos.end),
      position: pos
    });
    jump(tagMark.position.end);
  }
  tokens = tokens.concat(tokenize(reader2));
  return tokens;
};

// node_modules/orga/dist/tokenize/planning.js
var planning_default2 = ({ keywords, timezone }) => (reader2) => {
  const { now, match, eat, substring, getLine, jump } = reader2;
  const ws = eat("whitespaces");
  const pattern = `(${keywords.join("|")}):`;
  if (!match(RegExp(pattern, "y"))) {
    ws && jump(ws.position.start);
    return;
  }
  const currentLine = getLine();
  const { line, column, offset } = now();
  const getLocation = (_offset) => ({
    line,
    column: column + _offset,
    offset: offset + _offset
  });
  const all = [];
  const parseLastTimestamp = (end) => {
    if (all.length === 0)
      return;
    const { type, position } = all[all.length - 1];
    if (!position)
      throw Error(`position is ${position}`);
    if (type !== "planning.keyword")
      return;
    const endLocation = getLocation(end);
    const timestampPosition = { start: position.end, end: endLocation };
    const value = substring(timestampPosition.start, timestampPosition.end);
    all.push({
      type: "planning.timestamp",
      value: parse(value, { timezone }),
      position: timestampPosition
    });
  };
  let m;
  const p = RegExp(pattern, "g");
  while ((m = p.exec(currentLine)) !== null) {
    parseLastTimestamp(m.index);
    all.push({
      type: "planning.keyword",
      value: m[1],
      position: {
        start: getLocation(m.index),
        end: getLocation(p.lastIndex)
      }
    });
  }
  parseLastTimestamp(currentLine.length);
  eat("line");
  return all;
};

// node_modules/orga/dist/tokenize/table.js
var table_default2 = (reader2) => {
  const { eat, getChar, jump, endOfLine, indexOf } = reader2;
  const ws = eat("whitespaces");
  const char = getChar();
  if (char !== "|") {
    ws && jump(ws.position.start);
    return [];
  }
  if (getChar(1) === "-") {
    const hr = eat("line");
    const tokens2 = [{ type: "table.hr", position: hr.position }];
    const nl = eat("newline");
    if (nl)
      tokens2.push({ type: "newline", position: nl.position });
    return tokens2;
  }
  const startColumnSeparator = {
    type: "table.columnSeparator",
    position: eat().position
  };
  const tokens = [];
  const tokCells = () => {
    const pipe = indexOf("|");
    const end = pipe || endOfLine();
    if (!end)
      throw new Error(`what is happening: ${end}`);
    const inline = tokenize(reader2.read({ end }));
    tokens.push(...inline);
    jump(end);
    if (pipe) {
      const c = eat("char");
      tokens.push({
        type: "table.columnSeparator",
        position: c.position
      });
      tokCells();
    }
    const nl = eat("newline");
    if (nl) {
      tokens.push({
        type: "newline",
        position: nl.position
      });
    }
  };
  tokCells();
  return [startColumnSeparator, ...tokens];
};

// node_modules/orga/dist/tokenize/empty.js
function empty_default({ isStartOfLine, getLine, eat }) {
  const tokens = [];
  while (isStartOfLine()) {
    const l = getLine();
    if (l === null || l.replace(/\s/g, "").length > 0)
      break;
    const line = eat("line");
    if (!line)
      break;
    tokens.push({
      type: "emptyLine",
      position: line.position
    });
    const nl = eat("newline");
    if (!nl)
      break;
    tokens.push({
      type: "newline",
      position: nl.position
    });
  }
  return tokens;
}

// node_modules/orga/dist/tokenize/index.js
var PLANNING_KEYWORDS = ["DEADLINE", "SCHEDULED", "CLOSED"];
var tokenize2 = (text, options) => {
  const { timezone, todos, range } = options;
  const reader2 = read(text, range);
  const { getChar } = reader2;
  const globalTodoKeywordSets = todos.map(todo_keyword_set_default);
  const inBufferTodoKeywordSets = [];
  function todoKeywordSets() {
    return inBufferTodoKeywordSets.length === 0 ? globalTodoKeywordSets : inBufferTodoKeywordSets;
  }
  let tokens = [];
  let cursor = 0;
  const tokenizers = [
    ({ getChar: getChar2, eat }) => getChar2() === "\n" && {
      type: "newline",
      position: eat("char").position
    },
    headline_default2(todoKeywordSets),
    drawer_default2,
    planning_default2({ keywords: PLANNING_KEYWORDS, timezone }),
    keyword_default2,
    block_default2,
    latex_default2,
    list_default2,
    comment_default,
    table_default2,
    hr_default,
    footnote_default3
  ];
  function tok() {
    const all = empty_default(reader2);
    if (!getChar())
      return all;
    for (const t of tokenizers) {
      const result = t(reader2);
      if (!result)
        continue;
      const tokens2 = Array.isArray(result) ? result : [result];
      if (tokens2.length > 0) {
        return [...all, ...tokens2];
      }
    }
    const currentLine = reader2.read({ end: reader2.endOfLine() });
    const inlineTokens = tokenize(currentLine);
    reader2.jump(currentLine.now());
    return [...all, ...inlineTokens];
  }
  const peek = (offset = 0) => {
    const pos = cursor + offset;
    if (pos >= tokens.length) {
      tokens = tokens.concat(tok());
    }
    return tokens[pos];
  };
  const modify = (f, offset = 0) => {
    const pos = cursor + offset;
    const token = peek(offset);
    if (token !== void 0) {
      tokens[pos] = f(token);
    }
  };
  const _eat = (type = void 0) => {
    const t = peek();
    if (!t)
      return void 0;
    if (!type || type === t.type) {
      cursor += 1;
      return t;
    }
    return void 0;
  };
  return {
    peek,
    eat: _eat,
    eatAll(type) {
      let count = 0;
      while (_eat(type)) {
        count += 1;
      }
      return count;
    },
    match(cond, offset = 0) {
      const token = peek();
      if (!token)
        return false;
      if (typeof cond === "string") {
        return token.type === cond;
      }
      return cond.test(token.type);
    },
    all(max = void 0) {
      let _all = [];
      let tokens2 = tok();
      while (tokens2.length > 0) {
        _all = _all.concat(tokens2);
        tokens2 = tok();
      }
      return _all;
    },
    save: () => cursor,
    restore(point2) {
      cursor = point2;
    },
    addInBufferTodoKeywords(text2) {
      inBufferTodoKeywordSets.push(todo_keyword_set_default(text2));
    },
    substring: (pos) => reader2.substring(pos.start, pos.end),
    modify,
    get now() {
      const token = peek();
      return reader2.toIndex(token?.position.start ?? Infinity);
    },
    toOffset: (point2) => reader2.toIndex(point2),
    toPoint: (offset) => reader2.toPoint(offset)
  };
};

// node_modules/orga/dist/index.js
var tokenize3 = (text, options = {}) => {
  return tokenize2(text, withDefault(options));
};
var parse2 = (text, options = {}) => {
  const parser2 = makeParser(text, options);
  return parser2.parse();
};
function makeParser(text, options = {}) {
  const { range, ..._options } = withDefault(options);
  const start = range?.start;
  const lexer = tokenize3(text, {
    ..._options,
    range: start ? { start, end: Infinity } : void 0
  });
  return parser(lexer, { ..._options, range });
}

// node_modules/@orgajs/reorg-parse/index.js
function reorgParse(options) {
  this.parser = function(document) {
    return parse2(document, options);
  };
}

// node_modules/@orgajs/reorg/index.js
var reorg = unified().use(reorgParse).freeze();
export {
  reorg
};
//# sourceMappingURL=@orgajs_reorg.js.map
