import { not, test } from './index.js';
import { isSection } from '../types.js';
function point(d) {
    return { ...d };
}
export function createContext(lexer, options) {
    let stack = [];
    let snapshot = undefined;
    function enter(node) {
        const start = lexer.peek()?.position?.start ||
            lexer.peek(-1)?.position?.end || { line: 1, column: 1, offset: 0 };
        // @ts-ignore will add the end later
        node.position = { start: point(start) };
        stack.push(node);
        return node;
    }
    const tree = enter({
        type: 'document',
        properties: {},
        children: [],
    });
    const pop = () => {
        const node = stack.pop();
        const end = lexer.peek()?.position?.start ||
            lexer.peek(-1)?.position?.end || { line: 1, column: 1, offset: 0 };
        node.position.end = point(end);
        if (!node) {
            throw new Error('unexpected empty stack');
        }
        // attach to tree
        if (stack.length > 0) {
            push(node);
        }
        return node;
    };
    function exit(predicate, strict = true) {
        if (stack.length === 0)
            return; // never exit the root
        const last = stack[stack.length - 1];
        if (test(last, predicate)) {
            return pop();
        }
        if (strict) {
            throw new Error(`
can not strictly exit ${predicate},
actual: ${last.type}
location: line: ${last.position.start.line}, column: ${last.position.start.column}
`.trim());
        }
    }
    function exitTo(predicate) {
        exitAll(not(predicate));
    }
    function exitAll(predicate) {
        if (exit(predicate, false)) {
            exitAll(predicate);
        }
    }
    function getLevel() {
        let index = stack.length - 1;
        while (index > 0) {
            const node = stack[index];
            if (isSection(node)) {
                return node.level;
            }
            index -= 1;
        }
        return 0;
    }
    const push = (node) => {
        if (!node)
            return;
        if (stack.length === 0) {
            throw new Error('unexpected empty stack');
        }
        const parent = stack[stack.length - 1];
        parent.children.push(node);
        // node.parent = parent
    };
    return {
        options,
        attributes: {},
        enter,
        exit,
        exitAll,
        exitTo,
        push,
        addProp: function (key, value) {
            const k = key.toLowerCase().trim();
            const v = value.trim();
            const existing = tree.properties[k];
            if (existing) {
                if (Array.isArray(existing)) {
                    existing.push(v);
                }
                if (typeof existing === 'string') {
                    tree.properties[k] = [existing, v];
                }
            }
            else {
                tree.properties[k] = v;
            }
        },
        consume: function () {
            push(lexer.eat());
        },
        discard: function () {
            lexer.eat();
        },
        within: function (predicate) {
            return test(this.parent, predicate);
        },
        save: function () {
            const level = this.level;
            const attributes = this.attributes;
            snapshot = {
                stack: [...stack],
                level,
                attributes: { ...attributes },
                savePoint: lexer.save(),
            };
        },
        restore: function () {
            if (snapshot === undefined)
                return;
            this.attributes = { ...snapshot.attributes };
            stack = [...snapshot.stack];
            lexer.restore(snapshot.savePoint);
        },
        get parent() {
            return stack[stack.length - 1];
        },
        get tree() {
            return tree;
        },
        get lexer() {
            return lexer;
        },
        get level() {
            return getLevel();
        },
        get state() {
            const token = lexer.peek();
            const lines = [`lexer: ${lexer.save()}`];
            lines.push(`token: ${token ? token.type : 'EOF'}`);
            if (token) {
                lines.push(`content: ${lexer.substring(token.position)}`);
            }
            lines.push(`stack:   ${stack.map((n) => n.type).join(' > ')}`);
            return lines.join('\n');
        },
    };
}
